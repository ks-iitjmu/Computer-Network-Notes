<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 4: Network Layer</title>
    <style>
      body {
        font-family: "Segoe UI", Arial, sans-serif;
        font-size: 10px;
        line-height: 1.25;
        color: #222;
        max-width: 100%;
        margin: 0;
        padding: 15px;
        background-color: #fff;
      }
      .header-nav {
        column-span: all;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 15px;
        border-bottom: 1px solid #ccc;
      }
      .container {
        column-count: 3;
        column-gap: 20px;
        column-rule: 1px solid #eee;
      }
      h1 {
        column-span: all;
        text-align: center;
        font-size: 16px;
        border-bottom: 2px solid #000;
        margin-bottom: 10px;
        padding-bottom: 5px;
      }
      h2 {
        font-size: 12px;
        background-color: #e9ecef;
        padding: 3px 6px;
        border-left: 3px solid #0056b3;
        margin-top: 8px;
        margin-bottom: 4px;
        break-after: avoid;
        font-weight: 800;
      }
      h3 {
        font-size: 10.5px;
        font-weight: 700;
        text-transform: uppercase;
        margin-top: 6px;
        margin-bottom: 2px;
        color: #444;
        border-bottom: 1px dotted #ccc;
      }
      p {
        margin: 2px 0;
        text-align: justify;
      }
      ul,
      ol {
        margin: 0;
        padding-left: 12px;
      }
      li {
        margin-bottom: 1px;
      }
      strong {
        color: #000;
        font-weight: 700;
      }
      .highlight {
        background-color: #fffacd;
      }
      .formula {
        background-color: #f1f3f5;
        border: 1px solid #ced4da;
        padding: 2px;
        font-family: "Courier New", monospace;
        display: block;
        text-align: center;
        margin: 3px 0;
        font-weight: bold;
        font-size: 9px;
      }
      .box {
        border: 1px solid #444;
        padding: 4px;
        margin: 4px 0;
        background-color: #fff;
        break-inside: avoid;
      }
      .sub-box {
        border-left: 2px solid #ccc;
        padding-left: 5px;
        margin-left: 2px;
        font-style: italic;
      }
      .code {
        font-family: "Courier New", monospace;
        background: #eee;
        padding: 2px 4px;
        display: block;
        white-space: pre-wrap;
        margin: 2px 0;
        font-size: 9px;
        border-radius: 2px;
      }
      .footer {
        column-span: all;
        text-align: center;
        font-size: 12px;
        border-top: 2px solid #000;
        margin-top: 15px;
        padding-top: 10px;
        color: #444;
        font-weight: 600;
      }
      .chapter-nav {
        column-span: all;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 20px;
        padding: 15px 0;
        border-top: 1px solid #ccc;
      }
      .nav-btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 18px;
        background-color: #e9ecef;
        border-left: 3px solid #0056b3;
        text-decoration: none;
        color: #222;
        font-size: 11px;
        font-weight: 600;
        transition: all 0.2s ease;
      }
      .nav-btn:hover {
        background-color: #0056b3;
        color: #fff;
      }
      .nav-btn svg {
        width: 14px;
        height: 14px;
      }
      .nav-btn.next {
        border-left: none;
        border-right: 3px solid #0056b3;
      }
      .diagram {
        font-family: "Courier New", monospace;
        font-size: 8px;
        background-color: #fcfcfc;
        border: 1px dashed #bbb;
        padding: 5px;
        white-space: pre;
        overflow-x: auto;
        margin: 4px 0;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        font-size: 9px;
        margin: 4px 0;
      }
      th,
      td {
        border: 1px solid #ccc;
        padding: 2px;
        text-align: left;
      }
      th {
        background-color: #f0f0f0;
      }
      /* Tablet Responsive */
      @media screen and (max-width: 1024px) {
        .container {
          column-count: 2;
          column-gap: 15px;
        }
        body {
          font-size: 11px;
          padding: 12px;
        }
        h1 {
          font-size: 18px;
        }
        h2 {
          font-size: 13px;
        }
        h3 {
          font-size: 11.5px;
        }
        .formula {
          font-size: 10px;
        }
        .code {
          font-size: 10px;
        }
        .diagram {
          font-size: 7px;
        }
        table {
          font-size: 9px;
        }
      }
      /* Mobile Responsive */
      @media screen and (max-width: 600px) {
        .container {
          column-count: 1;
        }
        body {
          font-size: 12px;
          padding: 10px;
          line-height: 1.4;
        }
        h1 {
          font-size: 20px;
          padding-bottom: 8px;
        }
        h2 {
          font-size: 14px;
          padding: 6px 10px;
        }
        h3 {
          font-size: 12.5px;
          margin-top: 10px;
        }
        .box {
          padding: 8px;
          margin: 8px 0;
        }
        .formula {
          font-size: 11px;
          padding: 6px;
        }
        .code {
          font-size: 11px;
          padding: 6px;
          overflow-x: auto;
        }
        .diagram {
          font-size: 9px;
          padding: 8px;
          overflow-x: auto;
        }
        table {
          font-size: 10px;
        }
        th,
        td {
          padding: 4px;
        }
        ul,
        ol {
          padding-left: 18px;
        }
        li {
          margin-bottom: 4px;
        }
        .footer {
          font-size: 14px;
          padding-top: 15px;
          margin-top: 20px;
        }
        .header-nav,
        .chapter-nav {
          flex-direction: column;
          gap: 10px;
          align-items: stretch;
        }
        .nav-btn {
          justify-content: center;
          padding: 12px 16px;
          font-size: 12px;
        }
        .nav-btn.next {
          border-left: 3px solid #0056b3;
          border-right: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header-nav">
        <a href="Chapter3.html" class="nav-btn">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M19 12H5M12 19l-7-7 7-7" />
          </svg>
          Chapter 3: Transport Layer
        </a>
        <a href="index.html" class="nav-btn next">
          Home
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
            <polyline points="9 22 9 12 15 12 15 22" />
          </svg>
        </a>
      </div>

      <h1>Chapter 4: The Network Layer &mdash; Data Plane</h1>

      <!-- ============================================================ -->
      <!-- 4.1 OVERVIEW OF THE NETWORK LAYER                            -->
      <!-- ============================================================ -->
      <h2>4.1 Overview of the Network Layer</h2>
      <p>
        The Network Layer moves packets from a sending host to a receiving host.
        Every router in the path examines header fields to
        <strong>forward</strong> each packet toward its destination.
      </p>

      <h3>Two Key Network-Layer Functions</h3>
      <div class="box">
        <ul>
          <li>
            <strong>Forwarding (Data Plane):</strong> Move packets from router's
            input port to appropriate output port. A
            <em>local, per-router</em> action. Uses forwarding table.
            <ul>
              <li>Very fast — typically hardware-implemented.</li>
              <li>Time scale: nanoseconds.</li>
            </ul>
          </li>
          <li>
            <strong>Routing (Control Plane):</strong> Determine the route / path
            packets take from source to destination.
            <ul>
              <li>Network-wide process — involves all routers.</li>
              <li>Time scale: seconds.</li>
              <li>
                Implemented via routing algorithms (OSPF, BGP) or SDN
                controller.
              </li>
            </ul>
          </li>
        </ul>
      </div>

      <h3>Data Plane vs Control Plane</h3>
      <table>
        <tr>
          <th>Aspect</th>
          <th>Data Plane</th>
          <th>Control Plane</th>
        </tr>
        <tr>
          <td>Scope</td>
          <td>Per-router (local)</td>
          <td>Network-wide (global)</td>
        </tr>
        <tr>
          <td>Function</td>
          <td>Forwarding</td>
          <td>Routing</td>
        </tr>
        <tr>
          <td>Speed</td>
          <td>Nanoseconds</td>
          <td>Seconds</td>
        </tr>
        <tr>
          <td>Implementation</td>
          <td>Hardware (ASICs)</td>
          <td>Software</td>
        </tr>
        <tr>
          <td>Chapter</td>
          <td>Chapter 4</td>
          <td>Chapter 5</td>
        </tr>
      </table>

      <h3>Control Plane Approaches</h3>
      <div class="box">
        <strong>1. Traditional Per-Router Control Plane</strong>
        <ul>
          <li>
            Each router has a routing algorithm component that communicates with
            other routers.
          </li>
          <li>Routing algorithm runs in each router independently.</li>
          <li>
            Routing table computed locally from protocol messages (e.g., OSPF,
            BGP).
          </li>
        </ul>
        <strong>2. Software-Defined Networking (SDN) Control Plane</strong>
        <ul>
          <li>
            A logically centralized <strong>remote controller</strong> computes
            and installs forwarding tables in routers.
          </li>
          <li>Routers become simple forwarding devices (switches).</li>
          <li>
            Controller communicates with routers via APIs (e.g., OpenFlow).
          </li>
          <li>Separates "brains" (control) from "brawn" (forwarding).</li>
        </ul>
      </div>
      <div class="diagram">
        Traditional: SDN: ┌────────┐ routing ┌────────┐ ┌──────────────────┐
        │Router A│←────────→│Router B│ │ Remote Controller│ │ ctrl+ │ msgs │
        ctrl+ │ │ (computes tables)│ │ fwd │ │ fwd │ └──────┬───────┬────┘
        └────────┘ └────────┘ │ │ ┌────▼──┐ ┌──▼────┐ │Switch │ │Switch │ │(fwd)
        │ │(fwd) │ └───────┘ └───────┘
      </div>

      <h3>Network Service Model</h3>
      <p>Defines services provided by network layer to transport layer.</p>
      <div class="box">
        <strong>Possible Services (Theoretical):</strong>
        <ul>
          <li>Guaranteed delivery.</li>
          <li>Guaranteed delivery with bounded delay (e.g., within 40 ms).</li>
          <li>In-order packet delivery.</li>
          <li>Guaranteed minimum bandwidth.</li>
          <li>Security (encryption, integrity).</li>
        </ul>
        <strong>Internet's Actual Service Model: Best Effort</strong>
        <ul>
          <li>No guarantees on delivery, timing, ordering, or bandwidth.</li>
          <li>Simplicity → scalability → hugely successful.</li>
          <li>
            Sufficient bandwidth + adaptive protocols make it work well enough.
          </li>
        </ul>
      </div>

      <h3>Network Service Model Comparison</h3>
      <table>
        <tr>
          <th>Network</th>
          <th>Service</th>
          <th>Bandwidth</th>
          <th>Loss</th>
          <th>Order</th>
          <th>Timing</th>
        </tr>
        <tr>
          <td>Internet</td>
          <td>Best effort</td>
          <td>None</td>
          <td>No guarantee</td>
          <td>No guarantee</td>
          <td>No guarantee</td>
        </tr>
        <tr>
          <td>ATM CBR</td>
          <td>Constant bit rate</td>
          <td>Guaranteed</td>
          <td>Yes</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>ATM ABR</td>
          <td>Available bit rate</td>
          <td>Minimum</td>
          <td>No</td>
          <td>Yes</td>
          <td>No</td>
        </tr>
      </table>

      <h3>Virtual Circuit vs Datagram Networks</h3>
      <div class="box">
        <strong>Virtual Circuit (VC) Network:</strong>
        <ul>
          <li>
            Connection-oriented: A path (virtual circuit) is set up
            <em>before</em> data is sent.
          </li>
          <li>
            Three phases:
            <strong>VC setup &rarr; Data transfer &rarr; VC teardown</strong>.
          </li>
          <li>
            Each packet carries a <strong>VC number</strong> (not destination
            address).
          </li>
          <li>
            Every router on the path maintains <strong>state</strong> for each
            VC (VC number, input/output interfaces).
          </li>
          <li>
            Routers can reserve resources (bandwidth, buffers) along the path
            &rarr; QoS guarantees possible.
          </li>
          <li>Example: ATM, Frame Relay, X.25 (now mostly obsolete).</li>
          <li>
            Signaling protocols needed to establish/teardown VC (e.g., Q.2931
            for ATM).
          </li>
        </ul>
        <strong>Datagram Network:</strong>
        <ul>
          <li>
            Connectionless: No setup phase. Each packet treated independently.
          </li>
          <li>
            Each packet carries <strong>full destination address</strong>.
          </li>
          <li>
            Routers forward based on destination address using forwarding table.
          </li>
          <li>
            No per-flow state at routers &rarr; <strong>stateless</strong>.
          </li>
          <li>
            Packets may take <strong>different paths</strong> &rarr; may arrive
            out of order.
          </li>
          <li>No resource reservation &rarr; best-effort delivery.</li>
          <li><strong>The Internet uses datagram networking.</strong></li>
        </ul>
      </div>
      <table>
        <tr>
          <th>Feature</th>
          <th>Virtual Circuit</th>
          <th>Datagram</th>
        </tr>
        <tr>
          <td>Setup</td>
          <td>Required (call setup)</td>
          <td>None</td>
        </tr>
        <tr>
          <td>State in routers</td>
          <td>Yes (per VC)</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Addressing</td>
          <td>VC number (short)</td>
          <td>Full destination IP</td>
        </tr>
        <tr>
          <td>Routing decision</td>
          <td>At setup time only</td>
          <td>Per-packet</td>
        </tr>
        <tr>
          <td>QoS</td>
          <td>Easy to guarantee</td>
          <td>Difficult</td>
        </tr>
        <tr>
          <td>Failure recovery</td>
          <td>New VC must be setup</td>
          <td>Packets reroute automatically</td>
        </tr>
        <tr>
          <td>Complexity</td>
          <td>In network core</td>
          <td>At edges (end hosts)</td>
        </tr>
        <tr>
          <td>Example</td>
          <td>ATM, X.25, Frame Relay</td>
          <td>Internet (IP)</td>
        </tr>
      </table>

      <!-- ============================================================ -->
      <!-- 4.2 WHAT'S INSIDE A ROUTER                                   -->
      <!-- ============================================================ -->
      <h2>4.2 What's Inside a Router?</h2>
      <p>
        A router has four major components: input ports, switching fabric,
        output ports, and a routing processor.
      </p>

      <h3>Router Architecture Overview</h3>
      <div class="diagram">
        Routing Processor (Control Plane - SW) ┌──────────────────────┐ │
        Routing tables, │ │ protocols, SDN agent│ └──────────┬───────────┘ │
        ┌───────────┐ ┌────────▼────────┐ ┌───────────┐ │ Input │──→│ Switching
        │──→│ Output │ │ Ports │ │ Fabric │ │ Ports │ └───────────┘
        └─────────────────┘ └───────────┘ (Data Plane) (Data Plane) (Data Plane)
      </div>

      <h3>Input Port Functions</h3>
      <div class="box">
        <ol>
          <li>
            <strong>Line Termination:</strong> Physical layer — receive
            bit-level signal.
          </li>
          <li>
            <strong>Link-Layer Processing:</strong> Data link layer — e.g.,
            Ethernet decapsulation.
          </li>
          <li>
            <strong>Lookup &amp; Forwarding:</strong>
            <ul>
              <li>Extract destination IP from packet header.</li>
              <li>Consult forwarding table to determine output port.</li>
              <li>Forward packet to switching fabric.</li>
              <li>
                Goal: <strong>line speed</strong> processing (input ≈ output
                rate).
              </li>
            </ul>
          </li>
        </ol>
        <strong>Destination-Based Forwarding:</strong>
        <ul>
          <li>Forward based on <em>destination IP address only</em>.</li>
          <li>Traditional approach.</li>
        </ul>
        <strong>Generalized Forwarding (SDN):</strong>
        <ul>
          <li>
            Forward based on <em>any set of header fields</em> (src/dst IP,
            src/dst port, protocol, etc.).
          </li>
          <li>Used in OpenFlow-based switches.</li>
        </ul>
      </div>

      <h3>Longest Prefix Match (LPM)</h3>
      <div class="box">
        <p>
          When looking up a destination address in forwarding table, use the
          <strong>longest matching prefix</strong> to determine output link.
        </p>
        <strong>Example Forwarding Table:</strong>
        <table>
          <tr>
            <th>Prefix</th>
            <th>Output Link</th>
          </tr>
          <tr>
            <td>11001000 00010111 00010*** ********</td>
            <td>0</td>
          </tr>
          <tr>
            <td>11001000 00010111 00011000 ********</td>
            <td>1</td>
          </tr>
          <tr>
            <td>11001000 00010111 00011*** ********</td>
            <td>2</td>
          </tr>
          <tr>
            <td>Otherwise</td>
            <td>3</td>
          </tr>
        </table>
        <ul>
          <li>
            Destination <code>11001000 00010111 00011000 10101010</code> matches
            both prefix for link 1 and link 2.
          </li>
          <li>
            Link 1 prefix is <strong>longer</strong> (24 bits vs 21 bits) →
            <strong>Route to link 1.</strong>
          </li>
        </ul>
        <p>
          <strong>Implementation:</strong> Ternary Content Addressable Memory
          (TCAM) — looks up address in O(1) time regardless of table size.
          Millions of lookups per second.
        </p>
      </div>

      <h3>Switching Fabric</h3>
      <p>
        Transfers packets from input port to output port. The "heart" of the
        router.
      </p>
      <div class="box">
        <strong>Switching Rate:</strong> Rate at which packets can be
        transferred. Often measured as multiple of input/output line rate. N ×
        line rate desirable for N ports.

        <strong>Three Types of Switching Fabrics:</strong>
        <ol>
          <li>
            <strong>Switching via Memory (1st generation):</strong>
            <ul>
              <li>Packet copied to processor memory, then to output port.</li>
              <li>Speed limited by memory bandwidth.</li>
              <li>Two bus crossings per datagram.</li>
              <li>Cannot forward faster than memory read + write.</li>
            </ul>
          </li>
          <li>
            <strong>Switching via Bus:</strong>
            <ul>
              <li>Packet sent on shared bus from input to output port.</li>
              <li>Bus contention: only one packet at a time.</li>
              <li>Switching speed limited by bus bandwidth.</li>
              <li>
                Sufficient for access and enterprise routers (e.g., Cisco 5600:
                32 Gbps).
              </li>
            </ul>
          </li>
          <li>
            <strong>Switching via Interconnection Network (Crossbar):</strong>
            <ul>
              <li>Overcomes bus bandwidth limitation.</li>
              <li>
                2N buses connecting N input ports to N output ports (crossbar).
              </li>
              <li>
                Multiple packets can be forwarded simultaneously (non-blocking
                if to different output ports).
              </li>
              <li>Used in high-end routers (Cisco 12000: 60 Gbps crossbar).</li>
              <li>
                Multi-stage switching: build larger from smaller (Clos network).
              </li>
            </ul>
          </li>
        </ol>
      </div>
      <div class="diagram">
        Memory: Bus: Crossbar: In→[CPU]→Out In─┬─Bus─┬─Out In0──×──×──Out0 In─┘
        └─Out In1──×──×──Out1 In2──×──×──Out2
      </div>

      <h3>Input Port Queuing</h3>
      <div class="box">
        <ul>
          <li>
            Occurs when switching fabric is slower than combined input line
            rates.
          </li>
          <li>
            <strong>Head-of-Line (HOL) Blocking:</strong>
            <ul>
              <li>
                Packet at front of input queue blocks packets behind it, even if
                those packets could be switched.
              </li>
              <li>
                Queued datagram at front prevents others from being forwarded.
              </li>
            </ul>
          </li>
          <li>
            With HOL blocking, throughput limited to about
            <strong>58%</strong> of capacity even without congestion.
          </li>
        </ul>
        <div class="diagram">
          Input Port 1: [Pkt→Out1] [Pkt→Out2] [Pkt→Out3] ↑ HOL blocking! Input
          Port 2: [Pkt→Out1] [Pkt→Out3] [Pkt→Out2] ↑ Both want Out1, one must
          wait
        </div>
      </div>

      <h3>Output Port Queuing</h3>
      <div class="box">
        <ul>
          <li>
            Occurs when arrival rate from fabric exceeds output link rate.
          </li>
          <li>
            <strong>Buffering required:</strong> Queue packets when they arrive
            faster than transmission rate.
          </li>
          <li>
            <strong>Buffer overflow → Packet loss</strong> (drop policy needed).
          </li>
        </ul>
        <strong>How Much Buffering?</strong>
        <ul>
          <li>
            <strong>RFC 3439 rule of thumb:</strong>
            <span class="formula">Buffer = RTT × C</span>
            where C = link capacity, RTT ≈ 250 ms typical.
          </li>
          <li>
            <strong>Recent recommendation (with N TCP flows):</strong>
            <span class="formula">Buffer = (RTT × C) / √N</span>
            Less buffering needed when many flows are multiplexed (statistical
            multiplexing).
          </li>
        </ul>
      </div>

      <h3>Output Port Processing</h3>
      <div class="box">
        <ul>
          <li>
            Takes packets stored in output port buffer and
            <strong>transmits</strong> them over the outgoing link.
          </li>
          <li>
            Performs <strong>link-layer encapsulation</strong> (add L2
            header/trailer, e.g., Ethernet frame).
          </li>
          <li>
            Performs <strong>physical-layer transmission</strong> (convert to
            electrical/optical signal).
          </li>
          <li>
            Selects packet for transmission using
            <strong>packet scheduling</strong> discipline (FIFO, WFQ, etc.).
          </li>
          <li>
            The dequeuing and transmitting is essentially the reverse of input
            port processing.
          </li>
        </ul>
      </div>

      <h3>Active Queue Management (AQM)</h3>
      <div class="box">
        <p>
          Instead of waiting until the buffer is full (tail drop), AQM
          algorithms proactively drop or mark packets to signal
          <strong>incipient congestion</strong> <em>before</em> buffer overflow.
        </p>
        <strong>Random Early Detection (RED):</strong>
        <ul>
          <li>
            Monitors <strong>average queue length</strong> (weighted moving
            average).
          </li>
          <li>
            If avg queue &lt; min<sub>th</sub>: no action (packet queued
            normally).
          </li>
          <li>
            If min<sub>th</sub> &le; avg &le; max<sub>th</sub>:
            <strong>randomly drop/mark</strong> packet with probability p
            (increases linearly from 0 to max<sub>p</sub>).
          </li>
          <li>
            If avg &gt; max<sub>th</sub>: <strong>drop all</strong> arriving
            packets.
          </li>
          <li>
            Random drops prevent <strong>global synchronization</strong> &mdash;
            avoids all TCP senders backing off and restarting simultaneously.
          </li>
          <li>
            Early drops cause some TCP senders to reduce rate &rarr; queue
            drains before overflow.
          </li>
        </ul>
        <strong>ECN (Explicit Congestion Notification):</strong>
        <ul>
          <li>
            Alternative to dropping: <strong>mark</strong> packets instead of
            dropping them.
          </li>
          <li>
            Two ECN bits in IPv4 ToS field: ECT (ECN-Capable Transport) and CE
            (Congestion Experienced).
          </li>
          <li>Router sets CE bit when congestion is detected.</li>
          <li>
            Receiver echoes congestion signal in TCP ACK (ECE flag) &rarr;
            sender reduces rate (sets CWR flag).
          </li>
          <li>
            Benefit: congestion signal
            <strong>without packet loss</strong> &rarr; better performance, no
            retransmission needed.
          </li>
          <li>
            Requires support from both endpoints AND intermediate routers.
          </li>
        </ul>
        <strong>Other AQM Algorithms:</strong>
        <ul>
          <li>
            <em>PIE (Proportional Integral Controller Enhanced):</em> Controls
            queuing <strong>delay</strong> rather than queue length.
            Lightweight, used as default in Linux and DOCSIS.
          </li>
          <li>
            <em>CoDel (Controlled Delay):</em> Drops packets when sojourn time
            (time spent in queue) exceeds a target (e.g., 5ms) for an interval.
            Requires no tuning parameters.
          </li>
        </ul>
      </div>

      <h3>Packet Scheduling</h3>
      <p>Determines which queued packet is transmitted next on output link.</p>

      <div class="box">
        <strong>1. FIFO (First-In First-Out) / FCFS</strong>
        <ul>
          <li>Simplest: packets transmitted in arrival order.</li>
          <li>No differentiation between traffic types.</li>
          <li>
            <strong>Drop Policy (when buffer full):</strong>
            <ul>
              <li><em>Tail drop:</em> Drop arriving packet (most common).</li>
              <li><em>Priority drop:</em> Drop lowest-priority packet.</li>
              <li><em>Random drop:</em> Drop a random packet.</li>
            </ul>
          </li>
        </ul>
      </div>
      <div class="box">
        <strong>2. Priority Queuing</strong>
        <ul>
          <li>Packets classified into priority classes (e.g., high, low).</li>
          <li>Always send from highest priority non-empty queue first.</li>
          <li>Within each class: FIFO.</li>
          <li>
            <strong>Starvation risk:</strong> Low-priority packets may never be
            sent if high-priority queue always has packets.
          </li>
        </ul>
        <div class="diagram">
          Arriving classify ┌────────────────┐ send highest packets ──────────→
          │ High Priority │──────→ Out ├────────────────┤ │ Low Priority
          │──(wait) └────────────────┘
        </div>
      </div>
      <div class="box">
        <strong>3. Round Robin (RR)</strong>
        <ul>
          <li>
            Multiple classes, cyclically scan classes and serve one packet from
            each.
          </li>
          <li>Fair: each class gets equal turns.</li>
          <li>Skips empty queues.</li>
        </ul>
      </div>
      <div class="box">
        <strong>4. Weighted Fair Queuing (WFQ)</strong>
        <ul>
          <li>Generalized Round Robin.</li>
          <li>
            Each class gets a <strong>weighted</strong> share of bandwidth.
          </li>
          <li>Higher weight → more bandwidth.</li>
          <li>Minimum bandwidth guarantee per class.</li>
          <li>Widely deployed in modern routers.</li>
        </ul>
        <div class="diagram">
          w=3 ──→ ████████████ (3/6 = 50%) w=2 ──→ ████████ (2/6 = 33%) w=1 ──→
          ████ (1/6 = 17%)
        </div>
      </div>

      <h3>Packet Scheduling Summary</h3>
      <table>
        <tr>
          <th>Method</th>
          <th>Fairness</th>
          <th>Starvation</th>
          <th>Complexity</th>
        </tr>
        <tr>
          <td>FIFO</td>
          <td>None</td>
          <td>No</td>
          <td>Lowest</td>
        </tr>
        <tr>
          <td>Priority</td>
          <td>By class</td>
          <td>Yes (low prio)</td>
          <td>Low</td>
        </tr>
        <tr>
          <td>Round Robin</td>
          <td>Equal turns</td>
          <td>No</td>
          <td>Medium</td>
        </tr>
        <tr>
          <td>WFQ</td>
          <td>Weighted</td>
          <td>No</td>
          <td>Higher</td>
        </tr>
      </table>

      <!-- ============================================================ -->
      <!-- 4.3 THE INTERNET PROTOCOL (IP)                               -->
      <!-- ============================================================ -->
      <h2>4.3 The Internet Protocol: IPv4, Addressing, IPv6</h2>
      <p>
        IP is the "glue" of the Internet. The network layer has three major
        components: the IP protocol, routing protocols (control plane), and
        ICMP.
      </p>

      <h3>IPv4 Datagram Format</h3>
      <div class="diagram">
        0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |Version| IHL |Type of Service| Total Length |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Identification |Flags| Fragment Offset |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Time
        to Live | Protocol | Header Checksum |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Source IP Address |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Destination IP Address |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Options (if any) |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Payload (Data) |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </div>

      <h3>IPv4 Header Fields Explained</h3>
      <ul>
        <li>
          <strong>Version (4 bits):</strong> IP version. Always
          <code>4</code> for IPv4.
        </li>
        <li>
          <strong>Header Length / IHL (4 bits):</strong> Length of IP header in
          32-bit words.
          <ul>
            <li>Minimum = 5 (20 bytes, no options).</li>
            <li>Maximum = 15 (60 bytes).</li>
          </ul>
        </li>
        <li>
          <strong>Type of Service / DSCP+ECN (8 bits):</strong>
          <ul>
            <li>
              DSCP (6 bits): Differentiated Services Code Point — for QoS
              marking.
            </li>
            <li>
              ECN (2 bits): Explicit Congestion Notification (used with TCP).
            </li>
          </ul>
        </li>
        <li>
          <strong>Total Length (16 bits):</strong> Entire datagram (header +
          data) in bytes.
          <ul>
            <li>Maximum: 65,535 bytes.</li>
            <li>Typically ≤ 1500 bytes (Ethernet MTU).</li>
          </ul>
        </li>
        <li>
          <strong>Identification (16 bits):</strong> Unique ID for each
          datagram. Used for reassembly of fragments.
        </li>
        <li>
          <strong>Flags (3 bits):</strong>
          <ul>
            <li>Bit 0: Reserved (must be 0).</li>
            <li>
              <em>DF (Don't Fragment):</em> If set, router must not fragment
              this datagram.
            </li>
            <li>
              <em>MF (More Fragments):</em> Set on all fragments except the last
              one.
            </li>
          </ul>
        </li>
        <li>
          <strong>Fragment Offset (13 bits):</strong> Position of fragment in
          original datagram (in units of 8 bytes).
        </li>
        <li>
          <strong>Time to Live / TTL (8 bits):</strong>
          <ul>
            <li>Maximum number of hops. Decremented by 1 at each router.</li>
            <li>
              When TTL = 0, datagram is discarded → prevents infinite loops.
            </li>
            <li>ICMP "Time Exceeded" sent back to source.</li>
            <li>Typical initial values: 64, 128, or 255.</li>
          </ul>
        </li>
        <li>
          <strong>Protocol (8 bits):</strong> Upper-layer protocol. Specifies
          what to deliver payload to.
          <ul>
            <li>6 = TCP, 17 = UDP, 1 = ICMP, 89 = OSPF.</li>
            <li>
              Like port numbers for transport layer — "demultiplexing" at
              network layer.
            </li>
          </ul>
        </li>
        <li>
          <strong>Header Checksum (16 bits):</strong>
          <ul>
            <li>Computed over IP header only (not data).</li>
            <li>Must be recomputed at every router (TTL changes).</li>
            <li>Same 1's complement algorithm as TCP/UDP.</li>
          </ul>
        </li>
        <li>
          <strong>Source IP Address (32 bits):</strong> IP address of the
          originating host.
        </li>
        <li>
          <strong>Destination IP Address (32 bits):</strong> IP address of the
          target host.
        </li>
        <li>
          <strong>Options (variable, 0–40 bytes):</strong> Rarely used.
          Timestamp, record route, source route.
        </li>
      </ul>
      <p>
        <strong>IP header overhead:</strong> 20 bytes (typical) + TCP 20 bytes =
        <strong>40 bytes</strong> of header per segment.
      </p>

      <h3>IP Fragmentation &amp; Reassembly</h3>
      <div class="box">
        <p>
          Different links have different MTU (Maximum Transmission Unit). When a
          datagram is larger than the outgoing link MTU, the router
          <strong>fragments</strong> it.
        </p>
        <strong>Key Points:</strong>
        <ul>
          <li>
            Large IP datagram becomes several smaller datagrams (fragments).
          </li>
          <li>Fragments may travel different paths.</li>
          <li>
            <strong>Reassembly happens ONLY at the destination host</strong>
            (not at routers).
          </li>
          <li>Uses Identification, Flags (MF), and Fragment Offset fields.</li>
        </ul>
        <strong>Example:</strong>
        <ul>
          <li>
            Original datagram: 4000 bytes (3980 data + 20 header). ID = x.
          </li>
          <li>MTU of next link = 1500 bytes.</li>
          <li>Max data per fragment = 1500 - 20 = 1480 bytes.</li>
        </ul>
        <table>
          <tr>
            <th>Fragment</th>
            <th>Bytes</th>
            <th>ID</th>
            <th>MF</th>
            <th>Offset</th>
          </tr>
          <tr>
            <td>1</td>
            <td>1480</td>
            <td>x</td>
            <td>1</td>
            <td>0</td>
          </tr>
          <tr>
            <td>2</td>
            <td>1480</td>
            <td>x</td>
            <td>1</td>
            <td>185 (1480/8)</td>
          </tr>
          <tr>
            <td>3</td>
            <td>1020</td>
            <td>x</td>
            <td>0</td>
            <td>370 (2960/8)</td>
          </tr>
        </table>
        <p>
          <strong>If any fragment is lost, entire datagram is discarded</strong>
          (no retransmission at IP layer — transport layer handles this).
        </p>
      </div>

      <h3>IPv4 Addressing</h3>
      <p>
        An IP address is a <strong>32-bit identifier</strong> for a host/router
        <em>interface</em> (not for a host/router itself).
      </p>

      <div class="box">
        <strong>Interface:</strong> Connection between host/router and a
        physical link.
        <ul>
          <li>
            Routers typically have multiple interfaces (each with its own IP).
          </li>
          <li>Hosts typically have one or two (wired + wireless).</li>
        </ul>
        <strong>Dotted-Decimal Notation:</strong>
        <div class="code">
          11000000 10101000 00000001 00000001 = 192.168.1.1
        </div>
      </div>

      <h3>Subnets</h3>
      <div class="box">
        <strong>Subnet:</strong> A group of interfaces that can physically reach
        each other <em>without passing through a router</em>.
        <ul>
          <li>
            Devices in the same subnet share the same
            <strong>network prefix</strong> (high-order bits).
          </li>
          <li>The remaining bits = <strong>host part</strong>.</li>
        </ul>
        <strong>Subnet Mask:</strong> Indicates which bits are the network
        prefix.
        <div class="code">
          IP: 223.1.1.0/24 (subnet mask: 255.255.255.0) Network: 223.1.1.___
          (first 24 bits) Hosts: ___.___.___.[0-255] (last 8 bits)
        </div>
        <strong>How to identify subnets:</strong> Detach each interface from its
        router/host. Each isolated network (island) is a subnet.
      </div>
      <div class="diagram">
        223.1.1.0/24 ┌──────┬──────┐ .1 .2 .3 Host Host Host 223.1.2.0/24
        ┌──────┬──────┐ .1 .2 .4 Host Host Router───(223.1.3.0/24)
      </div>

      <h3>Subnet Calculation &mdash; Worked Examples</h3>
      <div class="box">
        <strong>Example 1: Given 200.23.16.0/21, find:</strong>
        <ul>
          <li>
            <strong>Subnet mask:</strong> /21 &rarr;
            11111111.11111111.11111000.00000000 = <strong>255.255.248.0</strong>
          </li>
          <li><strong>Number of host bits:</strong> 32 &minus; 21 = 11 bits</li>
          <li><strong>Total addresses:</strong> 2<sup>11</sup> = 2048</li>
          <li>
            <strong>Usable host addresses:</strong> 2048 &minus; 2 =
            <strong>2046</strong> (subtract network address + broadcast)
          </li>
          <li>
            <strong>Network address:</strong> 200.23.16.0 (all host bits = 0)
          </li>
          <li>
            <strong>Broadcast address:</strong> 200.23.23.255 (all host bits =
            1)
          </li>
          <li>
            <strong>Usable host range:</strong> 200.23.16.1 to 200.23.23.254
          </li>
        </ul>
        <strong>Example 2: How many /26 subnets fit in a /24?</strong>
        <ul>
          <li>Extra bits borrowed: 26 &minus; 24 = 2 bits</li>
          <li>Number of subnets: 2<sup>2</sup> = <strong>4 subnets</strong></li>
          <li>
            Hosts per subnet: 2<sup>(32&minus;26)</sup> &minus; 2 = 64 &minus; 2
            = <strong>62 hosts</strong>
          </li>
          <li>Subnets: x.x.x.0/26, x.x.x.64/26, x.x.x.128/26, x.x.x.192/26</li>
        </ul>
        <strong>Example 3: Given IP 192.168.5.130/25</strong>
        <ul>
          <li>Subnet mask: 255.255.255.128</li>
          <li>
            Network: 192.168.5.128/25 (130 in binary = 10000010; subnet boundary
            at .128)
          </li>
          <li>Broadcast: 192.168.5.255 (all host bits = 1)</li>
          <li>Usable range: 192.168.5.129 &ndash; 192.168.5.254</li>
        </ul>
      </div>

      <h3>Determining Subnet Membership</h3>
      <div class="box">
        <p>
          To check if two IPs are in the same subnet: perform
          <strong>bitwise AND</strong> of each IP with the subnet mask. If
          results are equal &rarr; same subnet.
        </p>
        <div class="code">
          IP1: 192.168.1.100 AND 255.255.255.0 = 192.168.1.0 IP2: 192.168.1.200
          AND 255.255.255.0 = 192.168.1.0 &rarr; Same subnet ✓ IP3:
          192.168.2.100 AND 255.255.255.0 = 192.168.2.0 &rarr; Different subnet
          ✗
        </div>
        <strong>Key IP addresses in a subnet:</strong>
        <ul>
          <li>
            <strong>Network address:</strong> All host bits = 0 (e.g.,
            192.168.1.0/24). Identifies the subnet.
            <em>Not assignable to hosts.</em>
          </li>
          <li>
            <strong>Broadcast address:</strong> All host bits = 1 (e.g.,
            192.168.1.255/24). Sends to all hosts on subnet.
            <em>Not assignable to hosts.</em>
          </li>
          <li>
            <strong>First usable:</strong> Network address + 1 (192.168.1.1)
          </li>
          <li>
            <strong>Last usable:</strong> Broadcast address &minus; 1
            (192.168.1.254)
          </li>
        </ul>
      </div>

      <h3>Classful Addressing (Historical)</h3>
      <table>
        <tr>
          <th>Class</th>
          <th>Leading Bits</th>
          <th>Network Bits</th>
          <th>Host Bits</th>
          <th>Range</th>
        </tr>
        <tr>
          <td>A</td>
          <td>0</td>
          <td>8</td>
          <td>24</td>
          <td>0.0.0.0 – 127.255.255.255</td>
        </tr>
        <tr>
          <td>B</td>
          <td>10</td>
          <td>16</td>
          <td>16</td>
          <td>128.0.0.0 – 191.255.255.255</td>
        </tr>
        <tr>
          <td>C</td>
          <td>110</td>
          <td>24</td>
          <td>8</td>
          <td>192.0.0.0 – 223.255.255.255</td>
        </tr>
        <tr>
          <td>D (multicast)</td>
          <td>1110</td>
          <td>—</td>
          <td>—</td>
          <td>224.0.0.0 – 239.255.255.255</td>
        </tr>
        <tr>
          <td>E (reserved)</td>
          <td>1111</td>
          <td>—</td>
          <td>—</td>
          <td>240.0.0.0 – 255.255.255.255</td>
        </tr>
      </table>
      <p>
        <strong>Problem:</strong> Wasteful. Class A = 16M hosts (too many),
        Class C = 254 hosts (too few for many orgs). Led to CIDR.
      </p>

      <h3>CIDR — Classless Inter-Domain Routing</h3>
      <div class="box">
        <p>
          <strong>RFC 4632.</strong> Generalized notion of subnet addressing.
          Network prefix can be <em>any length</em>.
        </p>
        <span class="formula">a.b.c.d/x, where x = number of prefix bits</span>
        <ul>
          <li>/23 → 2<sup>9</sup> = 512 addresses.</li>
          <li>/25 → 2<sup>7</sup> = 128 addresses.</li>
          <li>
            Enables <strong>route aggregation (supernetting):</strong> Multiple
            subnets advertised as one prefix.
            <ul>
              <li>
                200.23.16.0/23, 200.23.18.0/23, 200.23.20.0/23 can be aggregated
                to <strong>200.23.16.0/20</strong>.
              </li>
              <li>Reduces routing table size.</li>
            </ul>
          </li>
        </ul>
      </div>

      <h3>Special IP Addresses</h3>
      <table>
        <tr>
          <th>Address</th>
          <th>Purpose</th>
        </tr>
        <tr>
          <td>0.0.0.0/8</td>
          <td>"This" network (used during boot)</td>
        </tr>
        <tr>
          <td>10.0.0.0/8</td>
          <td>Private (RFC 1918)</td>
        </tr>
        <tr>
          <td>127.0.0.0/8</td>
          <td>Loopback (localhost)</td>
        </tr>
        <tr>
          <td>169.254.0.0/16</td>
          <td>Link-local (APIPA)</td>
        </tr>
        <tr>
          <td>172.16.0.0/12</td>
          <td>Private (RFC 1918)</td>
        </tr>
        <tr>
          <td>192.168.0.0/16</td>
          <td>Private (RFC 1918)</td>
        </tr>
        <tr>
          <td>255.255.255.255</td>
          <td>Broadcast (this LAN)</td>
        </tr>
      </table>

      <h3>How Does a Host Get an IP Address?</h3>
      <div class="box">
        <strong>1. Manual Configuration (Static):</strong>
        <ul>
          <li>
            System admin configures IP, subnet mask, default gateway, DNS
            server.
          </li>
          <li>Used for servers with stable addresses.</li>
        </ul>
        <strong
          >2. DHCP — Dynamic Host Configuration Protocol (RFC 2131):</strong
        >
        <ul>
          <li>Dynamically assigns IP from a pool.</li>
          <li>"Plug-and-play" — no manual configuration needed.</li>
          <li>Can return same address or a new one.</li>
          <li>
            DHCP also provides: Subnet mask, Default gateway (first-hop router),
            DNS server address, Lease time.
          </li>
        </ul>
      </div>

      <h3>DHCP Protocol — 4-Step Process (DORA)</h3>
      <div class="box">
        <div class="diagram">
          Client (0.0.0.0) DHCP Server | | |--1. DHCP DISCOVER
          (broadcast)-------->| src: 0.0.0.0:68 | dst: 255.255.255.255:67 | "Any
          DHCP servers?" | | |<--2. DHCP OFFER (broadcast)-----------| "Here's
          an IP you can use" | yiaddr: 223.1.2.4 | Lease time, etc. | | |--3.
          DHCP REQUEST (broadcast)--------->| "I'll take that IP" | Requested
          IP: 223.1.2.4 | | | |<--4. DHCP ACK (broadcast)-------------|
          "Confirmed. It's yours" | yiaddr: 223.1.2.4 | Lease = 3600s | |
        </div>
        <ul>
          <li>
            All messages use <strong>UDP</strong> (port 67 server, port 68
            client).
          </li>
          <li>Uses broadcast because client doesn't have IP yet.</li>
          <li>Transaction ID links messages in same exchange.</li>
          <li>
            <strong>Lease:</strong> IP is valid for limited time. Must renew
            before expiration.
          </li>
        </ul>
      </div>

      <h3>DHCP Relay Agent</h3>
      <div class="box">
        <p>
          DHCP server may not be on the same subnet as the client. A
          <strong>DHCP Relay Agent</strong> (typically the first-hop router)
          forwards DHCP messages between subnets.
        </p>
        <ul>
          <li>Client broadcasts DISCOVER on local subnet.</li>
          <li>
            Relay agent receives broadcast, converts to
            <strong>unicast</strong>, and forwards to DHCP server (on different
            subnet).
          </li>
          <li>
            Adds <strong>giaddr</strong> (gateway IP address) field so server
            knows which subnet the client is on &rarr; server allocates IP from
            correct pool.
          </li>
          <li>
            Server sends OFFER back to relay agent, which forwards to client via
            broadcast/unicast.
          </li>
          <li>
            Without relay agent, you&rsquo;d need a separate DHCP server on
            every subnet.
          </li>
        </ul>
      </div>

      <h3>DHCP Lease Lifecycle</h3>
      <div class="box">
        <ul>
          <li>
            <strong>Lease time:</strong> Duration for which the IP address is
            assigned (e.g., 1 hour, 24 hours, 7 days).
          </li>
          <li>
            <strong>Renewal (T1 = 50% of lease):</strong> Client unicasts DHCP
            REQUEST to same server to renew the lease.
          </li>
          <li>
            <strong>Rebinding (T2 = 87.5% of lease):</strong> If renewal fails,
            client broadcasts REQUEST to any DHCP server.
          </li>
          <li>
            <strong>Expiration:</strong> If no renewal/rebinding succeeds,
            client must release IP and restart DORA process.
          </li>
          <li>
            <strong>DHCP NACK:</strong> Server rejects a REQUEST (e.g., client
            moved to new subnet, address reassigned). Client must restart
            discovery.
          </li>
          <li>
            <strong>DHCP RELEASE:</strong> Client voluntarily gives up its lease
            before expiration (e.g., when disconnecting).
          </li>
          <li>
            <strong>DHCP INFORM:</strong> Client already has an IP but wants
            other configuration info (DNS server, gateway, domain name).
          </li>
        </ul>
      </div>

      <h3>How Does a Network Get Its Subnet?</h3>
      <ul>
        <li>
          <strong>ISP allocates</strong> portion of its address space to
          organization.
        </li>
        <li>ISP's block: 200.23.16.0/20</li>
        <li>Organization 1: 200.23.16.0/23</li>
        <li>Organization 2: 200.23.18.0/23</li>
        <li>Organization 3: 200.23.20.0/23</li>
      </ul>
      <p>
        <strong>ISPs get blocks from:</strong> ICANN (Internet Corporation for
        Assigned Names and Numbers) via Regional Internet Registries (RIRs):
        ARIN (N. America), RIPE (Europe), APNIC (Asia-Pacific), LACNIC (Latin
        America), AFRINIC (Africa).
      </p>

      <h3>NAT — Network Address Translation</h3>
      <div class="box">
        <p>
          <strong>RFC 3022.</strong> Allows multiple devices in a private
          network to share a <strong>single public IP address</strong>.
        </p>
        <strong>How NAT Works:</strong>
        <ul>
          <li>
            All devices in local network use <em>private</em> IP addresses
            (10.x.x.x, 192.168.x.x).
          </li>
          <li>NAT router has one <em>public</em> IP on its WAN side.</li>
          <li>
            <strong>Outgoing packets:</strong> Replace (source IP, source port)
            with (NAT IP, new port).
          </li>
          <li>
            <strong>Incoming packets:</strong> Use NAT translation table to map
            (NAT IP, port) back to (internal IP, original port).
          </li>
          <li>
            Uses <strong>16-bit port number field</strong> → up to ~65,000
            simultaneous connections with single public IP.
          </li>
        </ul>
        <div class="diagram">
          Private Network (10.0.0.0/24) Internet ┌───────────────────┐ │
          10.0.0.1 ─┐ │ NAT Router │ 10.0.0.2 ─┼──────┼──[10.0.0.4 |
          138.76.29.7]──→ Internet │ 10.0.0.3 ─┘ │ (private | public)
          └───────────────────┘
        </div>
        <strong>NAT Translation Table Example:</strong>
        <table>
          <tr>
            <th>LAN Side</th>
            <th>WAN Side</th>
          </tr>
          <tr>
            <td>10.0.0.1 : 3345</td>
            <td>138.76.29.7 : 5001</td>
          </tr>
          <tr>
            <td>10.0.0.2 : 3346</td>
            <td>138.76.29.7 : 5002</td>
          </tr>
          <tr>
            <td>10.0.0.1 : 2048</td>
            <td>138.76.29.7 : 5003</td>
          </tr>
        </table>
      </div>

      <h3>NAT Controversies</h3>
      <div class="box">
        <strong>Arguments Against NAT:</strong>
        <ul>
          <li>
            Routers should only process up to layer 3 (but NAT modifies port =
            layer 4).
          </li>
          <li>
            Violates <strong>end-to-end principle:</strong> external hosts
            cannot initiate connections to NAT'd hosts.
          </li>
          <li>Port number used for addressing (not process identification).</li>
          <li>Problem for P2P applications and servers behind NAT.</li>
        </ul>
        <strong>Arguments For NAT:</strong>
        <ul>
          <li>Conserves IPv4 addresses (huge practical benefit).</li>
          <li>Security: internal structure hidden from outside.</li>
          <li>
            Can change internal addresses without notifying outside world.
          </li>
        </ul>
        <strong>NAT Traversal Solutions:</strong>
        <ul>
          <li>
            <em>Port Forwarding:</em> Statically configure NAT to forward
            specific port to internal host.
          </li>
          <li><em>UPnP / IGD:</em> Protocol for automatic port mapping.</li>
          <li>
            <em>STUN/TURN/ICE:</em> Protocols for NAT traversal (used by WebRTC,
            VoIP).
          </li>
          <li>
            <em>Relay:</em> External relay server forwards traffic (Skype super
            nodes).
          </li>
        </ul>
      </div>

      <!-- ============================================================ -->
      <!-- IPv6                                                          -->
      <!-- ============================================================ -->
      <h3>IPv6 — The Next Generation IP</h3>
      <p>
        <strong>RFC 2460 (updated by RFC 8200).</strong> Developed to address
        IPv4 address exhaustion and add improvements.
      </p>

      <h3>Motivation for IPv6</h3>
      <ul>
        <li>
          <strong>Address Exhaustion:</strong> 32-bit (4.3 billion) addresses
          nearly depleted.
        </li>
        <li>
          <strong>Header improvements:</strong> Faster processing (fixed-length
          40 bytes, no options in base header).
        </li>
        <li><strong>QoS support:</strong> Flow labeling and priority.</li>
        <li>
          <strong>Security:</strong> IPsec support was originally mandatory.
        </li>
      </ul>

      <h3>IPv6 Datagram Format</h3>
      <div class="diagram">
        0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |Version| Traffic Class | Flow Label |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |
        Payload Length | Next Header | Hop Limit |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | +
        + | | + Source Address (128 bits) + | | + + | |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | | +
        + | | + Destination Address (128 bits) + | | + + | |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      </div>

      <h3>IPv6 Header Fields</h3>
      <ul>
        <li><strong>Version (4 bits):</strong> Always 6.</li>
        <li>
          <strong>Traffic Class (8 bits):</strong> Similar to IPv4's ToS/DSCP.
          Priority marking for QoS.
        </li>
        <li>
          <strong>Flow Label (20 bits):</strong> Identify packets belonging to
          same "flow" for special handling. Allows routers to treat related
          packets consistently.
        </li>
        <li>
          <strong>Payload Length (16 bits):</strong> Length of data following
          the 40-byte header.
        </li>
        <li>
          <strong>Next Header (8 bits):</strong>
          <ul>
            <li>Identifies upper-layer protocol (TCP=6, UDP=17) OR</li>
            <li>Identifies next extension header (replaces IPv4 options).</li>
          </ul>
        </li>
        <li>
          <strong>Hop Limit (8 bits):</strong> Same as TTL — decremented at each
          router, packet discarded at 0.
        </li>
        <li>
          <strong>Source Address (128 bits):</strong> IPv6 address of sender.
        </li>
        <li>
          <strong>Destination Address (128 bits):</strong> IPv6 address of
          receiver.
        </li>
      </ul>

      <h3>IPv6 vs IPv4 — What Changed?</h3>
      <div class="box">
        <strong>Removed from IPv4:</strong>
        <ul>
          <li>
            <strong>No Fragmentation at routers:</strong> Only source can
            fragment. If too big → ICMPv6 "Packet Too Big" sent back. Source
            adjusts using <em>Path MTU Discovery</em>.
          </li>
          <li>
            <strong>No Header Checksum:</strong> Checksum at transport (TCP/UDP)
            and link layers sufficient. Removes per-hop recomputation → faster
            forwarding.
          </li>
          <li>
            <strong>No Options field:</strong> Replaced by extension headers
            (Next Header chain). Base header is <strong>fixed 40 bytes</strong>.
          </li>
        </ul>
        <strong>Added/Changed:</strong>
        <ul>
          <li>128-bit addresses (vs 32-bit).</li>
          <li>Flow Label for QoS.</li>
          <li>Extension headers (more flexible than options).</li>
          <li>ICMPv6 replaces ICMP + ARP + IGMP.</li>
        </ul>
      </div>

      <h3>IPv6 vs IPv4 Comparison</h3>
      <table>
        <tr>
          <th>Feature</th>
          <th>IPv4</th>
          <th>IPv6</th>
        </tr>
        <tr>
          <td>Address Size</td>
          <td>32 bits (4B addresses)</td>
          <td>128 bits (3.4×10<sup>38</sup>)</td>
        </tr>
        <tr>
          <td>Header Size</td>
          <td>20–60 bytes (variable)</td>
          <td>40 bytes (fixed)</td>
        </tr>
        <tr>
          <td>Header Checksum</td>
          <td>Yes</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Fragmentation</td>
          <td>Routers + source</td>
          <td>Source only</td>
        </tr>
        <tr>
          <td>Options</td>
          <td>In header</td>
          <td>Extension headers</td>
        </tr>
        <tr>
          <td>NAT</td>
          <td>Widely used</td>
          <td>Not needed (enough addresses)</td>
        </tr>
        <tr>
          <td>Broadcast</td>
          <td>Yes</td>
          <td>No (multicast/anycast instead)</td>
        </tr>
        <tr>
          <td>ARP</td>
          <td>Separate protocol</td>
          <td>NDP (part of ICMPv6)</td>
        </tr>
        <tr>
          <td>Configuration</td>
          <td>DHCP/manual</td>
          <td>SLAAC + DHCPv6</td>
        </tr>
      </table>

      <h3>IPv6 Address Representation</h3>
      <div class="box">
        <ul>
          <li>
            Written as eight groups of four hex digits, separated by colons.
          </li>
          <li><code>2001:0db8:0000:0000:0000:ff00:0042:8329</code></li>
          <li>
            <strong>Shortening rules:</strong>
            <ul>
              <li>
                Leading zeros in each group can be omitted:
                <code>2001:db8:0:0:0:ff00:42:8329</code>
              </li>
              <li>
                One consecutive run of all-zero groups can be replaced by
                <code>::</code>
              </li>
              <li>Result: <code>2001:db8::ff00:42:8329</code></li>
            </ul>
          </li>
          <li>
            <strong>Loopback:</strong> <code>::1</code> (equivalent to
            127.0.0.1)
          </li>
          <li><strong>Link-local:</strong> <code>fe80::/10</code></li>
        </ul>
      </div>

      <h3>IPv6 Address Types</h3>
      <div class="box">
        <table>
          <tr>
            <th>Type</th>
            <th>Prefix</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>Global Unicast</td>
            <td>2000::/3</td>
            <td>
              Globally routable, equivalent to IPv4 public addresses. Assigned
              by ISPs via RIRs.
            </td>
          </tr>
          <tr>
            <td>Link-Local</td>
            <td>fe80::/10</td>
            <td>
              Auto-configured on every interface. Valid only on local link. Used
              for NDP, routing protocols.
              <strong>Not routable beyond the link.</strong>
            </td>
          </tr>
          <tr>
            <td>Unique Local (ULA)</td>
            <td>fc00::/7</td>
            <td>
              Equivalent to IPv4 private addresses (10.x, 172.16.x, 192.168.x).
              Not globally routable.
            </td>
          </tr>
          <tr>
            <td>Multicast</td>
            <td>ff00::/8</td>
            <td>
              One-to-many delivery. Replaces IPv4 broadcast. E.g., ff02::1 (all
              nodes), ff02::2 (all routers).
            </td>
          </tr>
          <tr>
            <td>Anycast</td>
            <td>(any unicast prefix)</td>
            <td>
              Same address assigned to multiple interfaces; packet delivered to
              <em>nearest</em> one (by routing metric). Used for load balancing,
              CDN.
            </td>
          </tr>
          <tr>
            <td>Loopback</td>
            <td>::1/128</td>
            <td>Equivalent to 127.0.0.1 in IPv4.</td>
          </tr>
          <tr>
            <td>Unspecified</td>
            <td>::/128</td>
            <td>
              All zeros. Used as source when no address assigned yet (like
              0.0.0.0).
            </td>
          </tr>
        </table>
        <p>
          <strong>Key:</strong> IPv6 has <strong>no broadcast</strong>.
          Multicast (ff02::1 = all-nodes) replaces broadcast functionality. This
          is more efficient as only interested nodes process the packet.
        </p>
      </div>

      <h3>IPv6 Global Unicast Address Structure</h3>
      <div class="box">
        <div class="diagram">
          | 48 bits | 16 bits | 64 bits | | Global Routing | Subnet | Interface
          ID | | Prefix (ISP) | ID | (EUI-64 or random) |
        </div>
        <ul>
          <li>
            <strong>Global Routing Prefix (48 bits):</strong> Assigned by
            ISP/RIR. Identifies the organization/site globally.
          </li>
          <li>
            <strong>Subnet ID (16 bits):</strong> Allows 2<sup>16</sup> = 65,536
            subnets within a single site.
          </li>
          <li>
            <strong>Interface ID (64 bits):</strong> Identifies the specific
            host interface. Often derived from MAC using EUI-64, or generated
            randomly for privacy.
          </li>
        </ul>
      </div>

      <h3>IPv6 Extension Headers</h3>
      <div class="box">
        <p>
          IPv6 base header is <strong>fixed 40 bytes</strong> &mdash; no
          options. Optional functionality uses
          <strong>extension headers</strong> chained via the Next Header field.
        </p>
        <div class="diagram">
          IPv6 Base Hdr &rarr; Ext Hdr 1 &rarr; Ext Hdr 2 &rarr; TCP/UDP Data
          (Next Hdr=0) (Next Hdr=43) (Next Hdr=6) (payload)
        </div>
        <strong
          >Common Extension Headers (recommended processing order):</strong
        >
        <table>
          <tr>
            <th>Header</th>
            <th>Next Hdr Value</th>
            <th>Purpose</th>
          </tr>
          <tr>
            <td>Hop-by-Hop Options</td>
            <td>0</td>
            <td>
              Options examined by <em>every</em> router on the path (e.g.,
              Jumbogram for packets &gt; 64KB, Router Alert).
            </td>
          </tr>
          <tr>
            <td>Routing</td>
            <td>43</td>
            <td>
              Lists intermediate routers the packet must visit (source routing).
              Type 2 used for Mobile IPv6.
            </td>
          </tr>
          <tr>
            <td>Fragment</td>
            <td>44</td>
            <td>
              Contains fragmentation info. Only source host fragments; routers
              do NOT fragment.
            </td>
          </tr>
          <tr>
            <td>Authentication (AH)</td>
            <td>51</td>
            <td>IPsec: provides data integrity + origin authentication.</td>
          </tr>
          <tr>
            <td>Encapsulating Security (ESP)</td>
            <td>50</td>
            <td>
              IPsec: provides encryption + confidentiality + authentication.
            </td>
          </tr>
          <tr>
            <td>Destination Options</td>
            <td>60</td>
            <td>Options examined only by the destination node.</td>
          </tr>
        </table>
        <ul>
          <li>
            Extension headers are processed <strong>strictly in order</strong>.
          </li>
          <li>
            Only Hop-by-Hop is examined by intermediate routers; all others
            processed at destination only.
          </li>
          <li>
            This makes router processing <strong>faster</strong> &mdash; routers
            typically only look at the 40-byte base header.
          </li>
          <li>
            Unlike IPv4 options (which make header variable-length), extension
            headers keep the base header fixed.
          </li>
        </ul>
      </div>

      <h3>SLAAC &mdash; Stateless Address Autoconfiguration</h3>
      <div class="box">
        <p>
          IPv6 hosts can automatically configure their own global addresses
          <strong>without a DHCP server</strong>. This is a major IPv6 feature.
        </p>
        <strong>Process:</strong>
        <ol>
          <li>
            <strong>Generate Link-Local Address:</strong> Host creates
            fe80::[Interface ID] using EUI-64 from MAC or random generation.
          </li>
          <li>
            <strong>Duplicate Address Detection (DAD):</strong> Host sends
            Neighbor Solicitation (NS) to its own address to check uniqueness on
            the link. If no response &rarr; address is unique.
          </li>
          <li>
            <strong>Router Solicitation (RS):</strong> Host sends RS (ICMPv6
            Type 133) to ff02::2 (all-routers multicast), requesting network
            configuration.
          </li>
          <li>
            <strong>Router Advertisement (RA):</strong> Router responds with RA
            (ICMPv6 Type 134) containing:
            <ul>
              <li>
                Network <strong>prefix</strong> and prefix length (e.g.,
                2001:db8:1::/64)
              </li>
              <li>Default gateway (router&rsquo;s link-local address)</li>
              <li>
                <strong>M flag</strong> (Managed): If set, use DHCPv6 for
                address assignment
              </li>
              <li>
                <strong>O flag</strong> (Other): If set, use DHCPv6 for other
                info (DNS, NTP)
              </li>
              <li>Prefix valid/preferred lifetime</li>
              <li>MTU for the link</li>
            </ul>
          </li>
          <li>
            <strong>Form Global Unicast Address:</strong> Host combines 64-bit
            prefix from RA + 64-bit Interface ID &rarr; complete 128-bit global
            address.
          </li>
        </ol>
        <strong>EUI-64 Interface ID Generation:</strong>
        <div class="code">
          MAC Address: AA:BB:CC:DD:EE:FF Step 1: Split in half: AA:BB:CC |
          DD:EE:FF Step 2: Insert FF:FE: AA:BB:CC:FF:FE:DD:EE:FF Step 3: Flip
          7th bit (U/L bit) of first byte Result: Interface ID =
          A8BB:CCFF:FEDD:EEFF
        </div>
        <ul>
          <li>
            <strong>Privacy concern:</strong> EUI-64 embeds the MAC address
            &rarr; device is trackable across networks.
          </li>
          <li>
            <strong>Solution:</strong> Modern OSes use
            <strong>privacy extensions</strong> (RFC 4941) &mdash; random,
            temporary Interface IDs that change periodically.
          </li>
        </ul>
      </div>

      <h3>DHCPv6 vs SLAAC Comparison</h3>
      <table>
        <tr>
          <th>Feature</th>
          <th>SLAAC</th>
          <th>DHCPv6</th>
        </tr>
        <tr>
          <td>Server needed</td>
          <td>No (stateless)</td>
          <td>Yes (stateful or stateless)</td>
        </tr>
        <tr>
          <td>Address assignment</td>
          <td>Host self-configures from RA prefix</td>
          <td>Server assigns specific address</td>
        </tr>
        <tr>
          <td>Admin control</td>
          <td>Limited (cannot control which address)</td>
          <td>Full (specific addresses, logging, policies)</td>
        </tr>
        <tr>
          <td>DNS info</td>
          <td>Via RA RDNSS option or DHCPv6</td>
          <td>Yes, directly provided</td>
        </tr>
        <tr>
          <td>Prefix info</td>
          <td>From Router Advertisement</td>
          <td>From server (can also use RA)</td>
        </tr>
        <tr>
          <td>Typical use case</td>
          <td>Simple/home networks, IoT devices</td>
          <td>Enterprise networks needing address tracking</td>
        </tr>
      </table>

      <h3>NDP &mdash; Neighbor Discovery Protocol</h3>
      <div class="box">
        <p>
          <strong>RFC 4861.</strong> NDP is an ICMPv6-based protocol that
          <strong
            >replaces ARP, ICMP Router Discovery, and ICMP Redirect</strong
          >
          from IPv4. It is fundamental to IPv6 operation.
        </p>
        <strong>Five key NDP message types:</strong>
        <table>
          <tr>
            <th>Message</th>
            <th>ICMPv6 Type</th>
            <th>Function</th>
          </tr>
          <tr>
            <td>Router Solicitation (RS)</td>
            <td>133</td>
            <td>
              Host asks routers for prefix, gateway, and configuration info.
            </td>
          </tr>
          <tr>
            <td>Router Advertisement (RA)</td>
            <td>134</td>
            <td>
              Router announces prefix, hop limit, MTU, configuration flags. Sent
              periodically + in response to RS.
            </td>
          </tr>
          <tr>
            <td>Neighbor Solicitation (NS)</td>
            <td>135</td>
            <td>
              <strong>Replaces ARP Request.</strong> Resolves IPv6 address
              &rarr; link-layer (MAC) address. Also used for Duplicate Address
              Detection (DAD).
            </td>
          </tr>
          <tr>
            <td>Neighbor Advertisement (NA)</td>
            <td>136</td>
            <td>
              <strong>Replaces ARP Reply.</strong> Response to NS containing the
              requested MAC address.
            </td>
          </tr>
          <tr>
            <td>Redirect</td>
            <td>137</td>
            <td>
              Router informs host of a better first-hop router for a specific
              destination.
            </td>
          </tr>
        </table>
        <strong>NDP vs ARP:</strong>
        <ul>
          <li>
            ARP uses <strong>broadcast</strong>; NDP uses efficient
            <strong>solicited-node multicast</strong> (ff02::1:ffXX:XXXX) &rarr;
            only relevant nodes process the request.
          </li>
          <li>
            ARP is a separate L2 protocol; NDP is part of
            <strong>ICMPv6 (L3)</strong> &rarr; more secure, extensible, can be
            authenticated.
          </li>
          <li>
            NDP includes <strong>DAD</strong> (Duplicate Address Detection)
            &mdash; no equivalent exists in ARP/IPv4.
          </li>
          <li>
            NDP supports <strong>NUD</strong> (Neighbor Unreachability
            Detection) &mdash; actively verifies that neighbors are still
            reachable.
          </li>
        </ul>
        <strong>NDP Address Resolution Example:</strong>
        <ol>
          <li>
            Host A wants to send to Host B (knows IPv6 address, needs MAC).
          </li>
          <li>
            A sends NS to solicited-node multicast address derived from
            B&rsquo;s IPv6 address.
          </li>
          <li>
            B receives NS (it joined that multicast group), responds with NA
            containing its MAC address.
          </li>
          <li>
            A caches the mapping in its
            <strong>Neighbor Cache</strong> (equivalent to ARP cache).
          </li>
        </ol>
      </div>

      <h3>Transition from IPv4 to IPv6</h3>
      <div class="box">
        <p>
          <strong>Problem:</strong> Cannot upgrade all routers simultaneously —
          billions of devices. Must coexist.
        </p>
        <strong>1. Dual Stack:</strong>
        <ul>
          <li>Routers/hosts run both IPv4 and IPv6 simultaneously.</li>
          <li>
            Use IPv6 when both endpoints support it; fall back to IPv4
            otherwise.
          </li>
          <li>
            <strong>Problem:</strong> When traversing IPv4-only routers,
            IPv6-specific features (flow label, etc.) are lost.
          </li>
        </ul>
        <strong>2. Tunneling:</strong>
        <ul>
          <li>
            IPv6 datagram carried as <strong>payload</strong> inside an IPv4
            datagram.
          </li>
          <li>
            "IPv6-over-IPv4" tunnel between dual-stack routers through IPv4-only
            region.
          </li>
          <li>IPv4 tunnel endpoints encapsulate/decapsulate.</li>
        </ul>
        <div class="diagram">
          IPv6 IPv4-only region IPv6 Node A ──[Tunnel Entry]══════[Tunnel
          Exit]── Node B IPv6 inside IPv4 datagram IPv4 hdr | IPv6 hdr | Data
        </div>
        <strong>3. Translation (NAT64):</strong>
        <ul>
          <li>Translates between IPv6 and IPv4 headers at the boundary.</li>
          <li>Used when one side is IPv6-only.</li>
        </ul>
      </div>

      <h3>IPv6 Adoption Status</h3>
      <ul>
        <li>Google: ~45% of traffic over IPv6 (2024).</li>
        <li>Major mobile networks heavily use IPv6.</li>
        <li>
          Adoption growing but slow — IPv4 + NAT still dominates many areas.
        </li>
        <li>Full transition estimated to take decades.</li>
      </ul>

      <!-- ============================================================ -->
      <!-- 4.4 GENERALIZED FORWARDING AND SDN                           -->
      <!-- ============================================================ -->
      <h2>4.4 Generalized Forwarding and SDN</h2>
      <p>
        Traditional forwarding uses <em>only</em> destination IP. Generalized
        forwarding (match+action) uses <em>any combination</em> of header fields
        — enabling rich network functionality.
      </p>

      <h3>Match-Plus-Action Abstraction</h3>
      <div class="box">
        <ul>
          <li>
            <strong>Match:</strong> Pattern against packet header fields
            (src/dst IP, src/dst port, protocol, VLAN, etc.).
          </li>
          <li>
            <strong>Action:</strong> What to do with matching packets:
            <ul>
              <li><em>Forward</em> to specific output port(s).</li>
              <li><em>Drop</em> the packet (firewall).</li>
              <li><em>Modify</em> header fields (NAT, load balancer).</li>
              <li><em>Send</em> to controller for special processing.</li>
            </ul>
          </li>
          <li>
            <strong>Unifying concept:</strong> Router, switch, firewall, NAT,
            load balancer are all the <em>same device</em> programmed
            differently!
          </li>
        </ul>
      </div>

      <h3>SDN Architecture &mdash; Three Layers</h3>
      <div class="box">
        <div class="diagram">
          ┌─────────────────────────────────────────┐ │ SDN Application Layer │
          Network apps: │ (Traffic Eng, Firewall, LB, Monitor) │ routing, access
          ├──────────── Northbound API (REST) ──────┤ control, monitoring │ SDN
          Control Layer (Controller/NOS) │ Logically centralized: │ - Network
          state &amp; topology mgmt │ ONOS, OpenDaylight, │ - Flow table
          computation │ Floodlight, Ryu, POX ├──────────── Southbound API
          (OpenFlow) ──┤ │ SDN Data Layer (Switches) │ Simple forwarding │ -
          Execute match+action rules │ devices (no routing │ - Maintain flow
          tables │ intelligence) └─────────────────────────────────────────┘
        </div>
        <strong>Layer Details:</strong>
        <ul>
          <li>
            <strong>Data Plane (Infrastructure Layer):</strong> Simple
            forwarding devices (OpenFlow switches). Execute match+action rules
            from flow tables programmed by controller. No routing intelligence
            in the switch itself.
          </li>
          <li>
            <strong>Control Plane (Controller / Network OS):</strong> The
            &ldquo;network operating system.&rdquo; Maintains global network
            view (topology graph, host locations, link states), computes
            forwarding rules, pushes flow table entries to switches. Examples:
            <em>ONOS, OpenDaylight, Floodlight, Ryu, POX</em>.
          </li>
          <li>
            <strong>Application Plane:</strong> Applications that use
            controller&rsquo;s northbound APIs to implement network functions
            (routing algorithms, load balancing, firewall policies, traffic
            engineering, monitoring).
          </li>
        </ul>
        <strong>Key APIs:</strong>
        <ul>
          <li>
            <strong>Northbound API:</strong> Interface between controller and
            applications. Typically REST API. Allows applications to read
            network state and install rules.
          </li>
          <li>
            <strong>Southbound API:</strong> Interface between controller and
            switches. Typically <strong>OpenFlow</strong>. Allows controller to
            program flow tables and read statistics.
          </li>
          <li>
            <strong>East/Westbound API:</strong> Interface between distributed
            controller instances for synchronization and consistency.
          </li>
        </ul>
      </div>

      <h3>SDN Controller Components</h3>
      <div class="box">
        <ul>
          <li>
            <strong>Communication Layer:</strong> Communicates with controlled
            switches via OpenFlow (southbound). Handles connection management,
            message parsing.
          </li>
          <li>
            <strong>Network-wide State Management:</strong> Maintains a global
            <em>network graph</em> (topology database), all switch flow tables,
            host information (IP, MAC, location), link states and statistics.
          </li>
          <li>
            <strong>Interface to Applications (Northbound):</strong> REST APIs
            for applications to read network state, register for events, and
            install forwarding rules.
          </li>
        </ul>
        <strong
          >&ldquo;Logically Centralized&rdquo; &ne; Physically
          Centralized:</strong
        >
        <ul>
          <li>
            For reliability, performance, and scalability, production SDN
            controllers are <strong>distributed</strong> (deployed as a cluster
            of servers).
          </li>
          <li>
            ONOS and OpenDaylight support multi-instance deployment with state
            synchronization.
          </li>
          <li>
            Appears as a <em>single logical entity</em> to both applications and
            switches.
          </li>
          <li>
            If one controller instance fails, others take over &rarr; fault
            tolerance.
          </li>
        </ul>
      </div>

      <h3>OpenFlow Protocol</h3>
      <div class="box">
        <p>
          Defines the communication between SDN controller and switches. Each
          flow table entry has:
        </p>
        <ol>
          <li>
            <strong>Match fields:</strong> Packet header values to match
            against.
            <ul>
              <li>Ingress port, Ethernet src/dst, Ethernet type, VLAN ID</li>
              <li>IP src/dst, IP protocol, IP ToS</li>
              <li>TCP/UDP src/dst port</li>
              <li>Wildcards: <code>*</code> matches any value.</li>
            </ul>
          </li>
          <li><strong>Counters:</strong> Number of packets/bytes matched.</li>
          <li>
            <strong>Actions:</strong> Forward, drop, modify, encapsulate, send
            to controller.
          </li>
          <li>
            <strong>Priority:</strong> Disambiguate overlapping rules (higher
            priority wins).
          </li>
        </ol>
      </div>

      <h3>OpenFlow Match Fields</h3>
      <table>
        <tr>
          <th>Layer</th>
          <th>Fields</th>
        </tr>
        <tr>
          <td>Ingress</td>
          <td>Switch port</td>
        </tr>
        <tr>
          <td>Link (L2)</td>
          <td>Ethernet src, Ethernet dst, Ethernet type, VLAN ID</td>
        </tr>
        <tr>
          <td>Network (L3)</td>
          <td>IP src, IP dst, IP protocol, IP ToS</td>
        </tr>
        <tr>
          <td>Transport (L4)</td>
          <td>TCP/UDP src port, TCP/UDP dst port</td>
        </tr>
      </table>

      <h3>SDN Use Cases — Examples</h3>
      <div class="box">
        <strong>1. Simple Forwarding (Router):</strong>
        <div class="code">
          Match: IP dst = 51.6.0.8 → Action: Forward port 6
        </div>

        <strong>2. Firewall:</strong>
        <div class="code">
          Match: IP src = 128.119.*.*, TCP dst port = 22 → Action: Drop
        </div>

        <strong>3. Load Balancer:</strong>
        <div class="code">
          Match: IP dst = 10.0.0.1 (VIP) → Action: Rewrite dst to 10.0.0.2 or
          10.0.0.3, Forward
        </div>

        <strong>4. NAT:</strong>
        <div class="code">
          Match: IP src = 10.0.0.* → Action: Rewrite src IP to 138.76.29.7,
          Forward to Internet port
        </div>
      </div>

      <h3>OpenFlow Protocol Messages</h3>
      <div class="box">
        <strong>1. Controller-to-Switch Messages:</strong>
        <ul>
          <li>
            <strong>Features:</strong> Controller queries switch capabilities
            (supported actions, buffer size, number of tables/ports).
          </li>
          <li>
            <strong>Configuration:</strong> Set/query switch configuration
            parameters (e.g., how to handle table-miss packets).
          </li>
          <li>
            <strong>Modify-State:</strong> Add, delete, or modify flow table
            entries and set switch port properties.
            <em>Primary mechanism for programming switches.</em>
          </li>
          <li>
            <strong>Packet-Out:</strong> Controller sends a specific packet out
            of a specified switch port (used when controller decides
            forwarding).
          </li>
          <li>
            <strong>Read-State:</strong> Controller requests flow/port/table
            statistics (counters: packet count, byte count, duration).
          </li>
          <li>
            <strong>Barrier:</strong> Ensures all previous messages are
            processed before subsequent ones.
          </li>
        </ul>
        <strong>2. Switch-to-Controller Messages:</strong>
        <ul>
          <li>
            <strong>Packet-In:</strong> Switch sends packet to controller when
            <strong>no matching flow rule</strong> found (table miss) or when
            action says "send to controller." Controller decides what to do.
          </li>
          <li>
            <strong>Flow-Removed:</strong> Notifies controller when a flow entry
            is removed (idle timeout, hard timeout, or explicit delete).
          </li>
          <li>
            <strong>Port-Status:</strong> Reports changes in port status (link
            up/down, configuration changes).
          </li>
        </ul>
        <strong>3. Symmetric Messages (either direction):</strong>
        <ul>
          <li>
            <strong>Hello:</strong> Exchanged at connection startup to negotiate
            protocol version.
          </li>
          <li>
            <strong>Echo Request/Reply:</strong> Keep-alive mechanism and
            latency measurement between controller and switch.
          </li>
          <li>
            <strong>Error:</strong> Reports failures in processing messages.
          </li>
        </ul>
      </div>

      <h3>OpenFlow Abstraction — Unifying Network Devices</h3>
      <table>
        <tr>
          <th>Traditional Device</th>
          <th>OpenFlow Match</th>
          <th>OpenFlow Action</th>
        </tr>
        <tr>
          <td>Router</td>
          <td>Longest prefix on IP dst</td>
          <td>Forward</td>
        </tr>
        <tr>
          <td>Switch</td>
          <td>Destination MAC</td>
          <td>Forward / Flood</td>
        </tr>
        <tr>
          <td>Firewall</td>
          <td>IP addresses, port numbers</td>
          <td>Permit / Deny</td>
        </tr>
        <tr>
          <td>NAT</td>
          <td>IP address, port</td>
          <td>Rewrite + Forward</td>
        </tr>
      </table>

      <!-- ============================================================ -->
      <!-- 4.5 MIDDLEBOXES                                              -->
      <!-- ============================================================ -->
      <h2>4.5 Middleboxes</h2>
      <p>
        Any network device that performs functions other than standard IP
        forwarding. They sit on the data path between source and destination.
      </p>

      <h3>Types of Middleboxes</h3>
      <div class="box">
        <ul>
          <li>
            <strong>NAT Boxes:</strong> Address/port translation (covered
            above).
          </li>
          <li>
            <strong>Firewalls:</strong>
            <ul>
              <li>
                Filter packets based on header values (addresses, ports, flags).
              </li>
              <li><em>Stateless:</em> Examine each packet independently.</li>
              <li>
                <em>Stateful:</em> Track connection state (e.g., allow return
                traffic for established connections).
              </li>
            </ul>
          </li>
          <li>
            <strong>Intrusion Detection Systems (IDS):</strong>
            <ul>
              <li>
                Deep packet inspection — examine payload for malicious patterns.
              </li>
              <li>Can detect viruses, attacks, suspicious activity.</li>
            </ul>
          </li>
          <li>
            <strong>Load Balancers:</strong>
            <ul>
              <li>Distribute incoming traffic across multiple servers.</li>
              <li>Single virtual IP → multiple backend servers.</li>
            </ul>
          </li>
          <li>
            <strong>Caches / CDN nodes:</strong> Store copies of content close
            to clients.
          </li>
          <li>
            <strong>Application-Level Gateways:</strong> Protocol-specific
            processing (e.g., SIP ALG).
          </li>
        </ul>
      </div>

      <h3>Middlebox Concerns</h3>
      <ul>
        <li>
          Break <strong>end-to-end principle</strong>: intermediate nodes
          modify/drop traffic.
        </li>
        <li>Increase complexity and potential points of failure.</li>
        <li>
          <strong>Ossification:</strong> Middleboxes may block or break new
          protocols (why QUIC uses UDP).
        </li>
        <li>
          <strong>NFV (Network Function Virtualization):</strong> Move middlebox
          functions to software on commodity hardware. Easier to deploy, manage,
          and scale.
        </li>
      </ul>

      <h3>Network Function Virtualization (NFV)</h3>
      <div class="box">
        <p>
          Move middlebox functions from
          <strong>dedicated hardware appliances</strong> to
          <strong>software running on commodity servers</strong> (COTS &mdash;
          Commercial Off-The-Shelf).
        </p>
        <ul>
          <li>
            Firewalls, NAT, load balancers, IDS, WAN optimizers run as
            <strong>Virtual Network Functions (VNFs)</strong> in VMs or
            containers.
          </li>
          <li>
            Deployed on standard x86 servers in data centers or at network edge.
          </li>
          <li>
            Can be dynamically instantiated, scaled, migrated, and chained.
          </li>
        </ul>
        <strong>Benefits:</strong>
        <ul>
          <li><em>Cost reduction:</em> No expensive proprietary hardware.</li>
          <li>
            <em>Flexibility:</em> Deploy new functions in minutes (vs months for
            hardware).
          </li>
          <li>
            <em>Scalability:</em> Spin up more instances as traffic grows.
          </li>
          <li>
            <em>Service Function Chaining:</em> Chain functions (Firewall &rarr;
            NAT &rarr; IDS &rarr; Load Balancer) in software-defined order.
          </li>
          <li>
            <em>Faster innovation:</em> Software updates vs hardware replacement
            cycles.
          </li>
        </ul>
        <strong>NFV + SDN Relationship:</strong>
        <ul>
          <li>
            SDN separates control plane from data plane (programmable
            forwarding).
          </li>
          <li>NFV virtualizes network functions (programmable middleboxes).</li>
          <li>
            Complementary technologies &mdash; together they enable fully
            programmable, flexible networks.
          </li>
        </ul>
      </div>

      <h3>The End-to-End Argument</h3>
      <div class="box">
        <p>
          <strong>Core principle (Saltzer, Reed, Clark, 1984):</strong>
          Functions that can only be correctly and completely implemented with
          the knowledge and help of endpoints should be placed at the
          <em>endpoints</em>, not in the network core.
        </p>
        <ul>
          <li>
            The network should be kept <strong>simple</strong> &mdash; just move
            packets from source to destination (best effort).
          </li>
          <li>
            Complex functions (reliability, encryption, error recovery,
            duplicate detection) belong at the <strong>end hosts</strong>.
          </li>
          <li>
            Example: Reliable delivery is implemented by TCP at the endpoints,
            not by the network (IP is unreliable).
          </li>
          <li>
            <strong>Middleboxes violate this principle</strong> by adding
            intelligence and state in the middle of the network.
          </li>
          <li>
            <strong>Tension:</strong> Practical needs (security, performance,
            address scarcity) have led to widespread middlebox deployment
            despite violating end-to-end.
          </li>
          <li>
            This principle guided the original Internet design and explains why
            IP provides only best-effort service.
          </li>
        </ul>
      </div>

      <!-- ============================================================ -->
      <!-- ICMP                                                          -->
      <!-- ============================================================ -->
      <h2>4.6 ICMP: Internet Control Message Protocol</h2>
      <p>
        <strong>RFC 792.</strong> Used by hosts and routers to communicate
        network-layer information: error reporting and diagnostics. Carried
        inside IP datagrams (protocol = 1).
      </p>

      <h3>ICMP Message Format</h3>
      <div class="box">
        <ul>
          <li><strong>Type (8 bits):</strong> Category of message.</li>
          <li>
            <strong>Code (8 bits):</strong> Sub-type providing more detail.
          </li>
          <li><strong>Checksum (16 bits):</strong> Error detection.</li>
          <li>
            <strong>First 8 bytes of offending datagram:</strong> Included for
            identification.
          </li>
        </ul>
      </div>

      <h3>Key ICMP Message Types</h3>
      <table>
        <tr>
          <th>Type</th>
          <th>Code</th>
          <th>Description</th>
        </tr>
        <tr>
          <td>0</td>
          <td>0</td>
          <td>Echo Reply (ping response)</td>
        </tr>
        <tr>
          <td>3</td>
          <td>0</td>
          <td>Destination Network Unreachable</td>
        </tr>
        <tr>
          <td>3</td>
          <td>1</td>
          <td>Destination Host Unreachable</td>
        </tr>
        <tr>
          <td>3</td>
          <td>2</td>
          <td>Destination Protocol Unreachable</td>
        </tr>
        <tr>
          <td>3</td>
          <td>3</td>
          <td>Destination Port Unreachable</td>
        </tr>
        <tr>
          <td>3</td>
          <td>4</td>
          <td>Fragmentation Needed, DF Set</td>
        </tr>
        <tr>
          <td>4</td>
          <td>0</td>
          <td>Source Quench (deprecated)</td>
        </tr>
        <tr>
          <td>5</td>
          <td>0</td>
          <td>Redirect (for network)</td>
        </tr>
        <tr>
          <td>8</td>
          <td>0</td>
          <td>Echo Request (ping)</td>
        </tr>
        <tr>
          <td>9</td>
          <td>0</td>
          <td>Router Advertisement</td>
        </tr>
        <tr>
          <td>10</td>
          <td>0</td>
          <td>Router Solicitation</td>
        </tr>
        <tr>
          <td>11</td>
          <td>0</td>
          <td>TTL Expired (Time Exceeded)</td>
        </tr>
        <tr>
          <td>12</td>
          <td>0</td>
          <td>Bad IP Header (Parameter Problem)</td>
        </tr>
      </table>

      <h3>Ping (Echo Request / Reply)</h3>
      <div class="box">
        <ul>
          <li>Sender sends ICMP Type 8 (Echo Request).</li>
          <li>Receiver responds with ICMP Type 0 (Echo Reply).</li>
          <li>Measures RTT and packet loss.</li>
          <li>Used to check if a host is reachable.</li>
        </ul>
        <div class="code">
          $ ping 8.8.8.8 64 bytes from 8.8.8.8: icmp_seq=1 ttl=118 time=12.3 ms
          64 bytes from 8.8.8.8: icmp_seq=2 ttl=118 time=11.8 ms
        </div>
      </div>

      <h3>Traceroute</h3>
      <div class="box">
        <p>Uses ICMP to discover the path packets take to a destination.</p>
        <strong>How Traceroute Works:</strong>
        <ol>
          <li>
            Send UDP packets (or ICMP Echo) with <strong>TTL = 1</strong>.
          </li>
          <li>
            First router: TTL → 0, drops packet, sends ICMP
            <strong>Time Exceeded (Type 11)</strong> back.
          </li>
          <li>Send with TTL = 2 → second router responds.</li>
          <li>Send with TTL = 3 → third router responds.</li>
          <li>Continue until destination reached.</li>
          <li>
            Destination returns ICMP
            <strong>Port Unreachable (Type 3, Code 3)</strong> for UDP, or Echo
            Reply for ICMP mode.
          </li>
        </ol>
        <p>Three probes sent per TTL level → three RTT measurements per hop.</p>
        <div class="code">
          $ traceroute google.com 1 192.168.1.1 1.2ms 1.1ms 1.0ms 2 10.10.10.1
          5.3ms 5.1ms 5.4ms 3 72.14.215.85 12.1ms 11.9ms 12.3ms 4 216.58.214.78
          13.2ms 13.0ms 13.1ms
        </div>
      </div>

      <h3>ICMPv6 &mdash; ICMP for IPv6</h3>
      <div class="box">
        <p>
          <strong>RFC 4443.</strong> IPv6 version of ICMP. Much more important
          than ICMPv4 because it subsumes multiple IPv4 protocols.
        </p>
        <strong>ICMPv6 replaces three separate IPv4 protocols:</strong>
        <ul>
          <li>
            <strong>ICMPv4:</strong> Error reporting, ping (Echo Request/Reply),
            traceroute.
          </li>
          <li>
            <strong>ARP:</strong> Replaced by NDP Neighbor
            Solicitation/Advertisement (ICMPv6 Types 135/136).
          </li>
          <li>
            <strong>IGMP:</strong> Replaced by MLD (Multicast Listener
            Discovery), also part of ICMPv6.
          </li>
        </ul>
        <strong>Key ICMPv6 Message Types:</strong>
        <table>
          <tr>
            <th>Type</th>
            <th>Name</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>1</td>
            <td>Destination Unreachable</td>
            <td>
              Packet cannot be delivered (codes: no route, admin prohibited,
              address unreachable, port unreachable).
            </td>
          </tr>
          <tr>
            <td>2</td>
            <td>Packet Too Big</td>
            <td>
              Packet exceeds link MTU. Includes the MTU value.
              <strong>Essential for Path MTU Discovery.</strong>
            </td>
          </tr>
          <tr>
            <td>3</td>
            <td>Time Exceeded</td>
            <td>
              Hop Limit reached 0 (like TTL Expired in IPv4). Used by
              traceroute.
            </td>
          </tr>
          <tr>
            <td>4</td>
            <td>Parameter Problem</td>
            <td>Error in IPv6 header fields or extension headers.</td>
          </tr>
          <tr>
            <td>128</td>
            <td>Echo Request</td>
            <td>Ping request (same function as ICMP Type 8).</td>
          </tr>
          <tr>
            <td>129</td>
            <td>Echo Reply</td>
            <td>Ping response (same function as ICMP Type 0).</td>
          </tr>
          <tr>
            <td>133</td>
            <td>Router Solicitation (RS)</td>
            <td>NDP: Host requests router information.</td>
          </tr>
          <tr>
            <td>134</td>
            <td>Router Advertisement (RA)</td>
            <td>NDP: Router announces prefix, gateway, flags.</td>
          </tr>
          <tr>
            <td>135</td>
            <td>Neighbor Solicitation (NS)</td>
            <td>
              NDP: IPv6 &rarr; MAC resolution (replaces ARP Request). Also used
              for DAD.
            </td>
          </tr>
          <tr>
            <td>136</td>
            <td>Neighbor Advertisement (NA)</td>
            <td>NDP: Response with MAC address (replaces ARP Reply).</td>
          </tr>
          <tr>
            <td>137</td>
            <td>Redirect</td>
            <td>NDP: Router informs host of better next hop.</td>
          </tr>
        </table>
        <p>
          <strong>Important:</strong> ICMPv6 is <em>mandatory</em> for IPv6
          operation (unlike ICMPv4 which is technically optional). Blocking
          ICMPv6 breaks IPv6 networking (no NDP, no PMTUD).
        </p>
      </div>

      <h3>Path MTU Discovery (PMTUD)</h3>
      <div class="box">
        <p>
          Since IPv6 routers <strong>do not fragment</strong> packets, the
          source must discover the smallest MTU along the entire path to avoid
          packet drops.
        </p>
        <strong>Process:</strong>
        <ol>
          <li>
            Source sends packet with size equal to its local link MTU (typically
            1500 bytes).
          </li>
          <li>
            If any router on the path has a link with smaller MTU, it
            <strong>drops</strong> the packet and sends back
            <strong>ICMPv6 &ldquo;Packet Too Big&rdquo;</strong> (Type 2)
            containing the link&rsquo;s MTU value.
          </li>
          <li>
            Source reduces packet size to the indicated MTU and retransmits.
          </li>
          <li>
            Process repeats until packets reach destination without
            &ldquo;Packet Too Big&rdquo; errors.
          </li>
          <li>
            The discovered Path MTU is <strong>cached</strong> and used for
            subsequent packets to that destination.
          </li>
        </ol>
        <p>
          IPv4 also supports PMTUD (using DF flag + ICMP &ldquo;Fragmentation
          Needed&rdquo;), but it&rsquo;s optional since IPv4 routers can
          fragment. In IPv6, PMTUD is <strong>essential</strong>.
        </p>
        <span class="formula"
          >Minimum MTU: IPv4 = 68 bytes | IPv6 = 1280 bytes</span
        >
      </div>

      <!-- ============================================================ -->
      <!-- ROUTING ALGORITHMS (Control Plane Intro)                      -->
      <!-- ============================================================ -->
      <h2>4.7 Routing Algorithms (Overview)</h2>
      <p>
        Routing algorithms determine the least-cost path from source to
        destination through the network graph. Covered in depth in Chapter 5,
        but essential context.
      </p>

      <h3>Graph Abstraction</h3>
      <div class="box">
        <ul>
          <li><strong>Nodes:</strong> Routers.</li>
          <li><strong>Edges:</strong> Physical links between routers.</li>
          <li>
            <strong>Edge Cost:</strong> Can represent bandwidth, delay, monetary
            cost, hop count, or congestion.
          </li>
          <li>
            <strong>Goal:</strong> Find least-cost path from source to all
            destinations.
          </li>
        </ul>
        <div class="diagram">
          5 u ──────── v |╲ |╲ 2| ╲1 3| ╲2 | ╲ | ╲ w ────x────y ── z 3 1 5
        </div>
      </div>

      <h3>Classification of Routing Algorithms</h3>
      <table>
        <tr>
          <th>Criterion</th>
          <th>Type 1</th>
          <th>Type 2</th>
        </tr>
        <tr>
          <td>Information</td>
          <td>
            <strong>Global (Link State):</strong> All routers have complete
            topology. E.g., OSPF.
          </td>
          <td>
            <strong>Decentralized (Distance Vector):</strong> Routers know only
            neighbors' costs. E.g., RIP, BGP.
          </td>
        </tr>
        <tr>
          <td>Dynamism</td>
          <td><strong>Static:</strong> Routes change slowly (manual).</td>
          <td>
            <strong>Dynamic:</strong> Routes change as topology/traffic changes.
          </td>
        </tr>
        <tr>
          <td>Load Sensitivity</td>
          <td><strong>Load-sensitive:</strong> Cost reflects congestion.</td>
          <td>
            <strong>Load-insensitive:</strong> Cost independent of traffic
            (modern Internet).
          </td>
        </tr>
      </table>

      <h3>Link-State Algorithm (Dijkstra's)</h3>
      <div class="box">
        <p>
          Each router has <strong>complete knowledge</strong> of network
          topology and link costs (obtained via link-state broadcasts).
        </p>
        <strong>Dijkstra's Algorithm:</strong>
        <ul>
          <li>
            Computes least-cost paths from one source to all destinations.
          </li>
          <li>
            <strong>Notation:</strong>
            <ul>
              <li>D(v): Current cost of least-cost path from source to v.</li>
              <li>p(v): Predecessor node along least-cost path to v.</li>
              <li>N': Set of nodes whose least-cost path is known.</li>
            </ul>
          </li>
        </ul>
        <div class="code">
          Initialization: N' = {u} (source node) for all nodes v: if v adjacent
          to u: D(v) = c(u,v) else: D(v) = ∞ Loop (until N' = all nodes): find w
          not in N' such that D(w) is minimum add w to N' for each neighbor v of
          w not in N': D(v) = min(D(v), D(w) + c(w,v))
        </div>
        <strong>Complexity:</strong> O(N²) with simple implementation, O(N log
        N) with min-heap.
      </div>

      <h3>Dijkstra's Algorithm — Worked Example</h3>
      <div class="box">
        <p>Using the graph above with source u:</p>
        <table>
          <tr>
            <th>Step</th>
            <th>N'</th>
            <th>D(v),p(v)</th>
            <th>D(w),p(w)</th>
            <th>D(x),p(x)</th>
            <th>D(y),p(y)</th>
            <th>D(z),p(z)</th>
          </tr>
          <tr>
            <td>0</td>
            <td>{u}</td>
            <td>5,u</td>
            <td>2,u</td>
            <td>1,u</td>
            <td>∞</td>
            <td>∞</td>
          </tr>
          <tr>
            <td>1</td>
            <td>{u,x}</td>
            <td>4,x</td>
            <td>2,u</td>
            <td>—</td>
            <td>2,x</td>
            <td>∞</td>
          </tr>
          <tr>
            <td>2</td>
            <td>{u,x,w}</td>
            <td>3,w</td>
            <td>—</td>
            <td>—</td>
            <td>2,x</td>
            <td>∞</td>
          </tr>
          <tr>
            <td>3</td>
            <td>{u,x,w,y}</td>
            <td>3,w</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
            <td>4,y</td>
          </tr>
          <tr>
            <td>4</td>
            <td>{u,x,w,y,v}</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
            <td>4,y</td>
          </tr>
          <tr>
            <td>5</td>
            <td>{u,x,w,y,v,z}</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
            <td>—</td>
          </tr>
        </table>
        <p>
          Shortest path tree from u: u→x (1), u→w (2), u→x→y (2), u→w→v (3),
          u→x→y→z (4).
        </p>
      </div>

      <h3>Oscillations Problem with Link-State</h3>
      <ul>
        <li>
          If link costs depend on traffic, routing can
          <strong>oscillate</strong>.
        </li>
        <li>
          All traffic shifts to new "cheapest" path → that path becomes
          expensive → shifts back.
        </li>
        <li>
          <strong>Solutions:</strong> Ensure link costs don't depend solely on
          traffic. Randomize timing of LS broadcasts.
        </li>
      </ul>

      <h3>Distance-Vector Algorithm (Bellman-Ford)</h3>
      <div class="box">
        <p>
          Decentralized: each node only talks to
          <strong>directly connected neighbors</strong>.
        </p>
        <strong>Bellman-Ford Equation:</strong>
        <span class="formula"
          >d<sub>x</sub>(y) = min<sub>v</sub> { c(x,v) + d<sub>v</sub>(y)
          }</span
        >
        <p>
          Least cost from x to y = min over all neighbors v of (cost to v + v's
          distance to y).
        </p>
        <strong>Algorithm:</strong>
        <ol>
          <li>
            Each node maintains distance vector D<sub>x</sub> =
            [D<sub>x</sub>(y): y ∈ N] for all destinations.
          </li>
          <li>
            Each node sends its DV to all neighbors periodically or when DV
            changes.
          </li>
          <li>
            When node x receives new DV from neighbor v, it updates:
            <div class="code">D_x(y) = min_v { c(x,v) + D_v(y) } for all y</div>
          </li>
          <li>If DV changed, notify all neighbors.</li>
          <li>Converges to correct least-cost paths.</li>
        </ol>
      </div>

      <h3>Count-to-Infinity Problem</h3>
      <div class="box">
        <p>
          <strong>"Bad news travels slowly"</strong> in distance-vector
          algorithms.
        </p>
        <strong>Example:</strong>
        <ul>
          <li>Link cost y→x increases from 4 to 60.</li>
          <li>Node y thinks it can reach x through z (cost 5+1=6).</li>
          <li>But z's route to x goes <em>through y</em>.</li>
          <li>
            Routing loop: y→z→y→z→... Costs increment by 1 each iteration until
            they exceed 60.
          </li>
          <li>Takes <strong>44 iterations</strong> to converge!</li>
        </ul>
        <strong>Solution: Poisoned Reverse</strong>
        <ul>
          <li>
            If z routes through y to reach x, z tells y that D<sub>z</sub>(x) =
            ∞.
          </li>
          <li>Prevents y from routing through z to x.</li>
          <li>
            <strong>Limitation:</strong> Only works for 2-node loops, not larger
            loops.
          </li>
        </ul>
      </div>

      <h3>LS vs DV Comparison</h3>
      <table>
        <tr>
          <th>Feature</th>
          <th>Link State (LS)</th>
          <th>Distance Vector (DV)</th>
        </tr>
        <tr>
          <td>Algorithm</td>
          <td>Dijkstra's</td>
          <td>Bellman-Ford</td>
        </tr>
        <tr>
          <td>Information</td>
          <td>Global topology</td>
          <td>Neighbor costs only</td>
        </tr>
        <tr>
          <td>Messages</td>
          <td>O(N×E) link-state broadcasts</td>
          <td>Exchanged between neighbors only</td>
        </tr>
        <tr>
          <td>Convergence</td>
          <td>O(N²) fast</td>
          <td>Varies, can be slow</td>
        </tr>
        <tr>
          <td>Robustness</td>
          <td>Each node computes own table</td>
          <td>Error propagates through network</td>
        </tr>
        <tr>
          <td>Example</td>
          <td>OSPF, IS-IS</td>
          <td>RIP, BGP (path-vector)</td>
        </tr>
      </table>

      <!-- ============================================================ -->
      <!-- KEY FORMULAS                                                  -->
      <!-- ============================================================ -->
      <h2>Key Formulas Summary</h2>
      <div class="box">
        <ul>
          <li>
            <strong>Buffer sizing:</strong>
            <span class="formula">B = RTT × C</span> (classic) or
            <span class="formula">B = (RTT × C) / √N</span> (N flows)
          </li>
          <li>
            <strong>Fragment Offset:</strong>
            <span class="formula">Offset = byte_position / 8</span>
          </li>
          <li>
            <strong>Max data per fragment:</strong>
            <span class="formula">= MTU − IP_header_size</span> (rounded down to
            multiple of 8)
          </li>
          <li>
            <strong>Number of host addresses in /x:</strong>
            <span class="formula">2<sup>(32−x)</sup> − 2</span> (subtract
            network + broadcast)
          </li>
          <li>
            <strong>CIDR block size:</strong>
            <span class="formula"
              >2<sup>(32−prefix_length)</sup> addresses</span
            >
          </li>
          <li>
            <strong>Dijkstra update:</strong>
            <span class="formula">D(v) = min(D(v), D(w) + c(w,v))</span>
          </li>
          <li>
            <strong>Bellman-Ford:</strong>
            <span class="formula"
              >d<sub>x</sub>(y) = min<sub>v</sub> { c(x,v) + d<sub>v</sub>(y)
              }</span
            >
          </li>
          <li>
            <strong>Number of subnets from /a to /b:</strong>
            <span class="formula">2<sup>(b−a)</sup> subnets</span>, each with
            2<sup>(32−b)</sup> − 2 usable hosts
          </li>
          <li>
            <strong>Number of fragments:</strong>
            <span class="formula">⌈ (Total data) / (MTU − IP header) ⌉</span>
            (ceiling division; each fragment's data must be multiple of 8 except
            last)
          </li>
          <li>
            <strong>NAT port mappings:</strong>
            <span class="formula"
              >Up to ~65,000 simultaneous connections per public IP</span
            >
            (16-bit port field)
          </li>
          <li>
            <strong>Subnet membership test:</strong>
            <span class="formula"
              >(IP<sub>1</sub> AND mask) == (IP<sub>2</sub> AND mask) &rarr;
              same subnet</span
            >
          </li>
          <li>
            <strong>WFQ bandwidth share:</strong>
            <span class="formula"
              >Class i share = w<sub>i</sub> / &Sigma;w<sub>j</sub></span
            >
          </li>
          <li>
            <strong>IPv6 addresses:</strong>
            <span class="formula"
              >2<sup>128</sup> = 3.4 × 10<sup>38</sup> addresses</span
            >
          </li>
        </ul>
      </div>

      <!-- ============================================================ -->
      <!-- IMPORTANT DEFINITIONS                                         -->
      <!-- ============================================================ -->
      <h2>Important Definitions</h2>
      <div class="box">
        <ul>
          <li>
            <strong>Forwarding:</strong> Local router action — move packet from
            input to correct output port using forwarding table.
          </li>
          <li>
            <strong>Routing:</strong> Network-wide process — determine
            end-to-end path using routing algorithms.
          </li>
          <li>
            <strong>Data Plane:</strong> Per-router functions that forward
            packets (hardware, fast).
          </li>
          <li>
            <strong>Control Plane:</strong> Network-wide logic that computes
            forwarding tables (software, slow).
          </li>
          <li>
            <strong>SDN:</strong> Software-Defined Networking — centralized
            controller programs forwarding tables remotely.
          </li>
          <li>
            <strong>LPM:</strong> Longest Prefix Match — forwarding rule with
            most specific (longest) matching prefix wins.
          </li>
          <li>
            <strong>MTU:</strong> Maximum Transmission Unit — largest packet
            size a link can carry.
          </li>
          <li>
            <strong>Fragmentation:</strong> Breaking a large datagram into
            smaller pieces to fit link MTU.
          </li>
          <li>
            <strong>CIDR:</strong> Classless Inter-Domain Routing —
            flexible-length subnet prefix (a.b.c.d/x).
          </li>
          <li>
            <strong>Subnet:</strong> Group of interfaces sharing same network
            prefix, reachable without a router.
          </li>
          <li>
            <strong>DHCP:</strong> Dynamic Host Configuration Protocol —
            auto-assigns IP, mask, gateway, DNS.
          </li>
          <li>
            <strong>NAT:</strong> Network Address Translation — maps private IPs
            to single public IP using port numbers.
          </li>
          <li>
            <strong>ICMP:</strong> Internet Control Message Protocol — error
            reporting and diagnostics (ping, traceroute).
          </li>
          <li>
            <strong>TTL:</strong> Time to Live — hop counter preventing infinite
            loops; decremented at each router.
          </li>
          <li>
            <strong>HOL Blocking:</strong> Head-of-Line Blocking —
            front-of-queue packet prevents forwarding of subsequent packets.
          </li>
          <li>
            <strong>WFQ:</strong> Weighted Fair Queuing — scheduling that
            allocates bandwidth proportional to weights.
          </li>
          <li>
            <strong>TCAM:</strong> Ternary Content Addressable Memory — hardware
            for O(1) prefix lookup.
          </li>
          <li>
            <strong>Dual Stack:</strong> Running IPv4 and IPv6 simultaneously
            during transition period.
          </li>
          <li>
            <strong>Tunneling:</strong> Encapsulating IPv6 inside IPv4 to cross
            IPv4-only regions.
          </li>
          <li>
            <strong>OpenFlow:</strong> Protocol for SDN controller to program
            switch flow tables.
          </li>
          <li>
            <strong>Middlebox:</strong> Network device performing functions
            beyond standard forwarding (NAT, firewall, IDS).
          </li>
          <li>
            <strong>NFV:</strong> Network Function Virtualization — implementing
            middlebox functions in software on commodity hardware.
          </li>
          <li>
            <strong>SLAAC:</strong> Stateless Address Autoconfiguration — IPv6
            hosts auto-generate addresses using prefix + MAC.
          </li>
          <li>
            <strong>Path MTU Discovery:</strong> Process of finding smallest MTU
            along path; source adjusts packet size.
          </li>
          <li>
            <strong>Link State:</strong> Routing approach where every router
            knows full topology (e.g., OSPF).
          </li>
          <li>
            <strong>Distance Vector:</strong> Routing approach where routers
            share cost estimates with neighbors (e.g., RIP).
          </li>
          <li>
            <strong>NDP:</strong> Neighbor Discovery Protocol &mdash; IPv6
            protocol (ICMPv6-based) that replaces ARP, ICMP Router Discovery,
            and Redirect. Handles address resolution, router discovery, DAD, and
            neighbor reachability.
          </li>
          <li>
            <strong>DAD:</strong> Duplicate Address Detection &mdash; NDP
            mechanism where a host verifies its tentative IPv6 address is unique
            on the link before using it.
          </li>
          <li>
            <strong>ICMPv6:</strong> ICMP for IPv6 &mdash; mandatory protocol
            that combines ICMPv4 + ARP + IGMP functionality. Includes NDP
            messages. Blocking it breaks IPv6.
          </li>
          <li>
            <strong>AQM:</strong> Active Queue Management &mdash; algorithms
            (RED, CoDel, PIE) that proactively drop/mark packets before buffer
            overflow to signal congestion early.
          </li>
          <li>
            <strong>RED:</strong> Random Early Detection &mdash; AQM algorithm
            that randomly drops packets based on average queue length to prevent
            global TCP synchronization.
          </li>
          <li>
            <strong>ECN:</strong> Explicit Congestion Notification &mdash; marks
            packets (instead of dropping) to signal congestion. Routers set CE
            bit; receiver echoes via TCP ECE flag.
          </li>
          <li>
            <strong>EUI-64:</strong> Method to generate a 64-bit IPv6 Interface
            ID from a 48-bit MAC address by inserting FF:FE in the middle and
            flipping the U/L bit.
          </li>
          <li>
            <strong>Anycast:</strong> IPv6 addressing where same address is
            assigned to multiple interfaces; packets delivered to the nearest
            one by routing metric.
          </li>
          <li>
            <strong>Virtual Circuit:</strong> Connection-oriented network where
            path is established before data transfer; packets carry VC number,
            routers maintain per-flow state (e.g., ATM).
          </li>
          <li>
            <strong>Datagram Network:</strong> Connectionless network where each
            packet is routed independently based on destination address; no
            per-flow state in routers (e.g., Internet/IP).
          </li>
          <li>
            <strong>End-to-End Argument:</strong> Design principle that
            application-specific functions should be implemented at endpoints,
            not in the network core.
          </li>
          <li>
            <strong>Clos Network:</strong> Multi-stage switching architecture
            built from smaller switch elements to create larger, non-blocking
            crossbar fabrics.
          </li>
          <li>
            <strong>Flow Table:</strong> In SDN/OpenFlow, a table in each switch
            containing match+action rules that define how packets are processed.
          </li>
          <li>
            <strong>DHCP Relay Agent:</strong> Router that forwards DHCP
            messages between clients and servers on different subnets, using
            giaddr field to identify the client&rsquo;s subnet.
          </li>
          <li>
            <strong>NAT64:</strong> Translation mechanism that allows IPv6-only
            hosts to communicate with IPv4-only servers by translating between
            IPv6 and IPv4 headers.
          </li>
        </ul>
      </div>

      <!-- ============================================================ -->
      <!-- HISTORICAL NOTES                                              -->
      <!-- ============================================================ -->
      <h2>Historical Notes</h2>
      <div class="box">
        <ul>
          <li>
            <strong>Vint Cerf &amp; Bob Kahn (1974):</strong> Designed TCP/IP;
            IP became the universal network-layer protocol.
          </li>
          <li>
            <strong>IPv4 (RFC 791, 1981):</strong> Original Internet Protocol,
            still dominant today.
          </li>
          <li>
            <strong>CIDR (1993, RFC 1519):</strong> Introduced to slow IPv4
            exhaustion and reduce routing table growth.
          </li>
          <li>
            <strong>NAT (mid-1990s):</strong> Pragmatic solution to address
            scarcity; controversial but universally deployed.
          </li>
          <li>
            <strong>IPv6 (RFC 2460, 1998):</strong> Designed with 128-bit
            addresses; adoption has been slow but steady.
          </li>
          <li>
            <strong>IANA IPv4 Pool Exhausted (Feb 2011):</strong> Last /8 blocks
            allocated to RIRs.
          </li>
          <li>
            <strong>OpenFlow (2008):</strong> Stanford research; launched SDN
            movement. Nick McKeown et al.
          </li>
          <li>
            <strong>SDN:</strong> Transformed network management; widely adopted
            in data centers (Google B4, 2013).
          </li>
          <li>
            <strong>Dijkstra (1959):</strong> Published shortest-path algorithm;
            foundation of link-state routing.
          </li>
          <li>
            <strong>Bellman-Ford (1958):</strong> Dynamic programming approach;
            foundation of distance-vector routing.
          </li>
        </ul>
      </div>

      <div class="chapter-nav">
        <a href="Chapter3.html" class="nav-btn">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M19 12H5M12 19l-7-7 7-7" />
          </svg>
          Chapter 3: Transport Layer
        </a>
        <a href="index.html" class="nav-btn next">
          Home
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
            <polyline points="9 22 9 12 15 12 15 22" />
          </svg>
        </a>
      </div>

      <div class="footer">
        Made by
        <a
          href="https://www.linkedin.com/in/ks-iitjmu"
          target="_blank"
          style="color: #0056b3; text-decoration: none"
          >Kunal Sharma</a
        >
      </div>
    </div>
  </body>
</html>
